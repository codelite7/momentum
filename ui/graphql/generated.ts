import { GraphQLClient, RequestOptions } from 'graphql-request';
import gql from 'graphql-tag';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
type GraphQLClientRequestHeaders = RequestOptions['requestHeaders'];
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  Cursor: { input: any; output: any; }
  Time: { input: any; output: any; }
};

export type Agent = Node & {
  __typename?: 'Agent';
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  messages: MessageConnection;
  model: Scalars['String']['output'];
  name: Scalars['String']['output'];
  updatedAt: Scalars['Time']['output'];
};


export type AgentMessagesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MessageOrder>>;
  where?: InputMaybe<MessageWhereInput>;
};

/** A connection to a list of items. */
export type AgentConnection = {
  __typename?: 'AgentConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AgentEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type AgentEdge = {
  __typename?: 'AgentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Agent>;
};

/** Ordering options for Agent connections */
export type AgentOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Agents. */
  field: AgentOrderField;
};

/** Properties by which Agent connections can be ordered. */
export enum AgentOrderField {
  CreatedAt = 'CREATED_AT',
  Model = 'MODEL',
  Name = 'NAME',
  UpdatedAt = 'UPDATED_AT'
}

/**
 * AgentWhereInput is used for filtering Agent objects.
 * Input was generated by ent.
 */
export type AgentWhereInput = {
  and?: InputMaybe<Array<AgentWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** messages edge predicates */
  hasMessages?: InputMaybe<Scalars['Boolean']['input']>;
  hasMessagesWith?: InputMaybe<Array<MessageWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** model field predicates */
  model?: InputMaybe<Scalars['String']['input']>;
  modelContains?: InputMaybe<Scalars['String']['input']>;
  modelContainsFold?: InputMaybe<Scalars['String']['input']>;
  modelEqualFold?: InputMaybe<Scalars['String']['input']>;
  modelGT?: InputMaybe<Scalars['String']['input']>;
  modelGTE?: InputMaybe<Scalars['String']['input']>;
  modelHasPrefix?: InputMaybe<Scalars['String']['input']>;
  modelHasSuffix?: InputMaybe<Scalars['String']['input']>;
  modelIn?: InputMaybe<Array<Scalars['String']['input']>>;
  modelLT?: InputMaybe<Scalars['String']['input']>;
  modelLTE?: InputMaybe<Scalars['String']['input']>;
  modelNEQ?: InputMaybe<Scalars['String']['input']>;
  modelNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<AgentWhereInput>;
  or?: InputMaybe<Array<AgentWhereInput>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type Bookmark = Node & {
  __typename?: 'Bookmark';
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  message?: Maybe<Message>;
  thread?: Maybe<Thread>;
  updatedAt: Scalars['Time']['output'];
  user: User;
};

/** A connection to a list of items. */
export type BookmarkConnection = {
  __typename?: 'BookmarkConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<BookmarkEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type BookmarkEdge = {
  __typename?: 'BookmarkEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Bookmark>;
};

/** Ordering options for Bookmark connections */
export type BookmarkOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Bookmarks. */
  field: BookmarkOrderField;
};

/** Properties by which Bookmark connections can be ordered. */
export enum BookmarkOrderField {
  CreatedAt = 'CREATED_AT',
  UpdatedAt = 'UPDATED_AT'
}

/**
 * BookmarkWhereInput is used for filtering Bookmark objects.
 * Input was generated by ent.
 */
export type BookmarkWhereInput = {
  and?: InputMaybe<Array<BookmarkWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** message edge predicates */
  hasMessage?: InputMaybe<Scalars['Boolean']['input']>;
  hasMessageWith?: InputMaybe<Array<MessageWhereInput>>;
  /** thread edge predicates */
  hasThread?: InputMaybe<Scalars['Boolean']['input']>;
  hasThreadWith?: InputMaybe<Array<ThreadWhereInput>>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<BookmarkWhereInput>;
  or?: InputMaybe<Array<BookmarkWhereInput>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

/**
 * CreateAgentInput is used for create Agent object.
 * Input was generated by ent.
 */
export type CreateAgentInput = {
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  messageIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  model: Scalars['String']['input'];
  name: Scalars['String']['input'];
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * CreateBookmarkInput is used for create Bookmark object.
 * Input was generated by ent.
 */
export type CreateBookmarkInput = {
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  messageID?: InputMaybe<Scalars['ID']['input']>;
  threadID?: InputMaybe<Scalars['ID']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  userID: Scalars['ID']['input'];
};

/**
 * CreateMessageInput is used for create Message object.
 * Input was generated by ent.
 */
export type CreateMessageInput = {
  bookmarkIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  content: Scalars['String']['input'];
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  sentByAgentID?: InputMaybe<Scalars['ID']['input']>;
  sentByUserID?: InputMaybe<Scalars['ID']['input']>;
  threadID: Scalars['ID']['input'];
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * CreateThreadInput is used for create Thread object.
 * Input was generated by ent.
 */
export type CreateThreadInput = {
  bookmarkIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  childID?: InputMaybe<Scalars['ID']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdByID: Scalars['ID']['input'];
  messageIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  name: Scalars['String']['input'];
  parentID?: InputMaybe<Scalars['ID']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * CreateUserInput is used for create User object.
 * Input was generated by ent.
 */
export type CreateUserInput = {
  bookmarkIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  email: Scalars['String']['input'];
  messageIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  threadIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

export type Message = Node & {
  __typename?: 'Message';
  bookmarks: BookmarkConnection;
  content: Scalars['String']['output'];
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  sentByAgent?: Maybe<Agent>;
  sentByUser?: Maybe<User>;
  thread: Thread;
  updatedAt: Scalars['Time']['output'];
};


export type MessageBookmarksArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BookmarkOrder>>;
  where?: InputMaybe<BookmarkWhereInput>;
};

/** A connection to a list of items. */
export type MessageConnection = {
  __typename?: 'MessageConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MessageEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type MessageEdge = {
  __typename?: 'MessageEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Message>;
};

/** Ordering options for Message connections */
export type MessageOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Messages. */
  field: MessageOrderField;
};

/** Properties by which Message connections can be ordered. */
export enum MessageOrderField {
  CreatedAt = 'CREATED_AT',
  UpdatedAt = 'UPDATED_AT'
}

/**
 * MessageWhereInput is used for filtering Message objects.
 * Input was generated by ent.
 */
export type MessageWhereInput = {
  and?: InputMaybe<Array<MessageWhereInput>>;
  /** content field predicates */
  content?: InputMaybe<Scalars['String']['input']>;
  contentContains?: InputMaybe<Scalars['String']['input']>;
  contentContainsFold?: InputMaybe<Scalars['String']['input']>;
  contentEqualFold?: InputMaybe<Scalars['String']['input']>;
  contentGT?: InputMaybe<Scalars['String']['input']>;
  contentGTE?: InputMaybe<Scalars['String']['input']>;
  contentHasPrefix?: InputMaybe<Scalars['String']['input']>;
  contentHasSuffix?: InputMaybe<Scalars['String']['input']>;
  contentIn?: InputMaybe<Array<Scalars['String']['input']>>;
  contentLT?: InputMaybe<Scalars['String']['input']>;
  contentLTE?: InputMaybe<Scalars['String']['input']>;
  contentNEQ?: InputMaybe<Scalars['String']['input']>;
  contentNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** bookmarks edge predicates */
  hasBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  hasBookmarksWith?: InputMaybe<Array<BookmarkWhereInput>>;
  /** sent_by_agent edge predicates */
  hasSentByAgent?: InputMaybe<Scalars['Boolean']['input']>;
  hasSentByAgentWith?: InputMaybe<Array<AgentWhereInput>>;
  /** sent_by_user edge predicates */
  hasSentByUser?: InputMaybe<Scalars['Boolean']['input']>;
  hasSentByUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** thread edge predicates */
  hasThread?: InputMaybe<Scalars['Boolean']['input']>;
  hasThreadWith?: InputMaybe<Array<ThreadWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<MessageWhereInput>;
  or?: InputMaybe<Array<MessageWhereInput>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type Mutation = {
  __typename?: 'Mutation';
  createAgent?: Maybe<Agent>;
  createBookmark?: Maybe<Bookmark>;
  createMessage?: Maybe<Message>;
  createThread?: Maybe<Thread>;
  createUser?: Maybe<User>;
  deleteBookmark: Scalars['Boolean']['output'];
};


export type MutationCreateAgentArgs = {
  input: CreateAgentInput;
};


export type MutationCreateBookmarkArgs = {
  input: CreateBookmarkInput;
};


export type MutationCreateMessageArgs = {
  input: CreateMessageInput;
};


export type MutationCreateThreadArgs = {
  input: CreateThreadInput;
};


export type MutationCreateUserArgs = {
  input: CreateUserInput;
};


export type MutationDeleteBookmarkArgs = {
  id: Scalars['ID']['input'];
};

/**
 * An object with an ID.
 * Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
 */
export type Node = {
  /** The id of the object. */
  id: Scalars['ID']['output'];
};

/** Possible directions in which to order a list of items when provided an `orderBy` argument. */
export enum OrderDirection {
  /** Specifies an ascending order for a given `orderBy` argument. */
  Asc = 'ASC',
  /** Specifies a descending order for a given `orderBy` argument. */
  Desc = 'DESC'
}

/**
 * Information about pagination in a connection.
 * https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
 */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['Cursor']['output']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean']['output'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean']['output'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['Cursor']['output']>;
};

export type Query = {
  __typename?: 'Query';
  agents: AgentConnection;
  bookmarks: BookmarkConnection;
  messages: MessageConnection;
  /** Fetches an object given its ID. */
  node?: Maybe<Node>;
  /** Lookup nodes by a list of IDs. */
  nodes: Array<Maybe<Node>>;
  threads: ThreadConnection;
  users: UserConnection;
};


export type QueryAgentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AgentOrder>>;
  where?: InputMaybe<AgentWhereInput>;
};


export type QueryBookmarksArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BookmarkOrder>>;
  where?: InputMaybe<BookmarkWhereInput>;
};


export type QueryMessagesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MessageOrder>>;
  where?: InputMaybe<MessageWhereInput>;
};


export type QueryNodeArgs = {
  id: Scalars['ID']['input'];
};


export type QueryNodesArgs = {
  ids: Array<Scalars['ID']['input']>;
};


export type QueryThreadsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ThreadOrder>>;
  where?: InputMaybe<ThreadWhereInput>;
};


export type QueryUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserOrder>>;
  where?: InputMaybe<UserWhereInput>;
};

export type Thread = Node & {
  __typename?: 'Thread';
  bookmarks: BookmarkConnection;
  child?: Maybe<Thread>;
  createdAt: Scalars['Time']['output'];
  createdBy: User;
  id: Scalars['ID']['output'];
  messages: MessageConnection;
  name: Scalars['String']['output'];
  parent?: Maybe<Thread>;
  updatedAt: Scalars['Time']['output'];
};


export type ThreadBookmarksArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BookmarkOrder>>;
  where?: InputMaybe<BookmarkWhereInput>;
};


export type ThreadMessagesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MessageOrder>>;
  where?: InputMaybe<MessageWhereInput>;
};

/** A connection to a list of items. */
export type ThreadConnection = {
  __typename?: 'ThreadConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ThreadEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type ThreadEdge = {
  __typename?: 'ThreadEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Thread>;
};

/** Ordering options for Thread connections */
export type ThreadOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Threads. */
  field: ThreadOrderField;
};

/** Properties by which Thread connections can be ordered. */
export enum ThreadOrderField {
  CreatedAt = 'CREATED_AT',
  Name = 'NAME',
  UpdatedAt = 'UPDATED_AT'
}

/**
 * ThreadWhereInput is used for filtering Thread objects.
 * Input was generated by ent.
 */
export type ThreadWhereInput = {
  and?: InputMaybe<Array<ThreadWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** bookmarks edge predicates */
  hasBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  hasBookmarksWith?: InputMaybe<Array<BookmarkWhereInput>>;
  /** child edge predicates */
  hasChild?: InputMaybe<Scalars['Boolean']['input']>;
  hasChildWith?: InputMaybe<Array<ThreadWhereInput>>;
  /** created_by edge predicates */
  hasCreatedBy?: InputMaybe<Scalars['Boolean']['input']>;
  hasCreatedByWith?: InputMaybe<Array<UserWhereInput>>;
  /** messages edge predicates */
  hasMessages?: InputMaybe<Scalars['Boolean']['input']>;
  hasMessagesWith?: InputMaybe<Array<MessageWhereInput>>;
  /** parent edge predicates */
  hasParent?: InputMaybe<Scalars['Boolean']['input']>;
  hasParentWith?: InputMaybe<Array<ThreadWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<ThreadWhereInput>;
  or?: InputMaybe<Array<ThreadWhereInput>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

/**
 * UpdateAgentInput is used for update Agent object.
 * Input was generated by ent.
 */
export type UpdateAgentInput = {
  addMessageIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  clearMessages?: InputMaybe<Scalars['Boolean']['input']>;
  model?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  removeMessageIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * UpdateBookmarkInput is used for update Bookmark object.
 * Input was generated by ent.
 */
export type UpdateBookmarkInput = {
  clearMessage?: InputMaybe<Scalars['Boolean']['input']>;
  clearThread?: InputMaybe<Scalars['Boolean']['input']>;
  messageID?: InputMaybe<Scalars['ID']['input']>;
  threadID?: InputMaybe<Scalars['ID']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  userID?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * UpdateMessageInput is used for update Message object.
 * Input was generated by ent.
 */
export type UpdateMessageInput = {
  addBookmarkIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  clearBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  clearSentByAgent?: InputMaybe<Scalars['Boolean']['input']>;
  clearSentByUser?: InputMaybe<Scalars['Boolean']['input']>;
  content?: InputMaybe<Scalars['String']['input']>;
  removeBookmarkIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  sentByAgentID?: InputMaybe<Scalars['ID']['input']>;
  sentByUserID?: InputMaybe<Scalars['ID']['input']>;
  threadID?: InputMaybe<Scalars['ID']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * UpdateThreadInput is used for update Thread object.
 * Input was generated by ent.
 */
export type UpdateThreadInput = {
  addBookmarkIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addMessageIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  childID?: InputMaybe<Scalars['ID']['input']>;
  clearBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  clearChild?: InputMaybe<Scalars['Boolean']['input']>;
  clearMessages?: InputMaybe<Scalars['Boolean']['input']>;
  clearParent?: InputMaybe<Scalars['Boolean']['input']>;
  createdByID?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  parentID?: InputMaybe<Scalars['ID']['input']>;
  removeBookmarkIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeMessageIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * UpdateUserInput is used for update User object.
 * Input was generated by ent.
 */
export type UpdateUserInput = {
  addBookmarkIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addMessageIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addThreadIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  clearBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  clearMessages?: InputMaybe<Scalars['Boolean']['input']>;
  clearThreads?: InputMaybe<Scalars['Boolean']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  removeBookmarkIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeMessageIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeThreadIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

export type User = Node & {
  __typename?: 'User';
  bookmarks: BookmarkConnection;
  createdAt: Scalars['Time']['output'];
  email: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  messages: MessageConnection;
  threads: ThreadConnection;
  updatedAt: Scalars['Time']['output'];
};


export type UserBookmarksArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BookmarkOrder>>;
  where?: InputMaybe<BookmarkWhereInput>;
};


export type UserMessagesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MessageOrder>>;
  where?: InputMaybe<MessageWhereInput>;
};


export type UserThreadsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ThreadOrder>>;
  where?: InputMaybe<ThreadWhereInput>;
};

/** A connection to a list of items. */
export type UserConnection = {
  __typename?: 'UserConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type UserEdge = {
  __typename?: 'UserEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<User>;
};

/** Ordering options for User connections */
export type UserOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Users. */
  field: UserOrderField;
};

/** Properties by which User connections can be ordered. */
export enum UserOrderField {
  CreatedAt = 'CREATED_AT',
  Email = 'EMAIL',
  UpdatedAt = 'UPDATED_AT'
}

/**
 * UserWhereInput is used for filtering User objects.
 * Input was generated by ent.
 */
export type UserWhereInput = {
  and?: InputMaybe<Array<UserWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** email field predicates */
  email?: InputMaybe<Scalars['String']['input']>;
  emailContains?: InputMaybe<Scalars['String']['input']>;
  emailContainsFold?: InputMaybe<Scalars['String']['input']>;
  emailEqualFold?: InputMaybe<Scalars['String']['input']>;
  emailGT?: InputMaybe<Scalars['String']['input']>;
  emailGTE?: InputMaybe<Scalars['String']['input']>;
  emailHasPrefix?: InputMaybe<Scalars['String']['input']>;
  emailHasSuffix?: InputMaybe<Scalars['String']['input']>;
  emailIn?: InputMaybe<Array<Scalars['String']['input']>>;
  emailLT?: InputMaybe<Scalars['String']['input']>;
  emailLTE?: InputMaybe<Scalars['String']['input']>;
  emailNEQ?: InputMaybe<Scalars['String']['input']>;
  emailNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** bookmarks edge predicates */
  hasBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  hasBookmarksWith?: InputMaybe<Array<BookmarkWhereInput>>;
  /** messages edge predicates */
  hasMessages?: InputMaybe<Scalars['Boolean']['input']>;
  hasMessagesWith?: InputMaybe<Array<MessageWhereInput>>;
  /** threads edge predicates */
  hasThreads?: InputMaybe<Scalars['Boolean']['input']>;
  hasThreadsWith?: InputMaybe<Array<ThreadWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<UserWhereInput>;
  or?: InputMaybe<Array<UserWhereInput>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type BookmarkFragment = { __typename?: 'Bookmark', id: string, createdAt: any, updatedAt: any, user: { __typename?: 'User', id: string, createdAt: any, updatedAt: any, email: string }, thread?: { __typename?: 'Thread', id: string, createdAt: any, updatedAt: any, name: string } | null, message?: { __typename?: 'Message', id: string, createdAt: any, updatedAt: any, content: string } | null };

export type BookmarksQueryVariables = Exact<{
  after?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BookmarkOrder> | BookmarkOrder>;
  where?: InputMaybe<BookmarkWhereInput>;
}>;


export type BookmarksQuery = { __typename?: 'Query', bookmarks: { __typename?: 'BookmarkConnection', totalCount: number, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean, startCursor?: any | null, endCursor?: any | null }, edges?: Array<{ __typename?: 'BookmarkEdge', cursor: any, node?: { __typename?: 'Bookmark', id: string, createdAt: any, updatedAt: any, user: { __typename?: 'User', id: string, createdAt: any, updatedAt: any, email: string }, thread?: { __typename?: 'Thread', id: string, createdAt: any, updatedAt: any, name: string } | null, message?: { __typename?: 'Message', id: string, createdAt: any, updatedAt: any, content: string } | null } | null } | null> | null } };

export type BookmarkQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type BookmarkQuery = { __typename?: 'Query', bookmarks: { __typename?: 'BookmarkConnection', edges?: Array<{ __typename?: 'BookmarkEdge', node?: { __typename?: 'Bookmark', id: string, createdAt: any, updatedAt: any, user: { __typename?: 'User', id: string, createdAt: any, updatedAt: any, email: string }, thread?: { __typename?: 'Thread', id: string, createdAt: any, updatedAt: any, name: string } | null, message?: { __typename?: 'Message', id: string, createdAt: any, updatedAt: any, content: string } | null } | null } | null> | null } };

export type CreateBookmarkMutationVariables = Exact<{
  input: CreateBookmarkInput;
}>;


export type CreateBookmarkMutation = { __typename?: 'Mutation', createBookmark?: { __typename?: 'Bookmark', id: string } | null };

export type DeleteBookmarkMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type DeleteBookmarkMutation = { __typename?: 'Mutation', deleteBookmark: boolean };

export type ThreadMessageFragment = { __typename?: 'Message', id: string, createdAt: any, updatedAt: any, content: string, sentByAgent?: { __typename?: 'Agent', id: string, createdAt: any, updatedAt: any } | null, sentByUser?: { __typename?: 'User', id: string, createdAt: any, updatedAt: any, email: string } | null, bookmarks: { __typename?: 'BookmarkConnection', edges?: Array<{ __typename?: 'BookmarkEdge', node?: { __typename?: 'Bookmark', id: string, createdAt: any, updatedAt: any, user: { __typename?: 'User', id: string, createdAt: any, updatedAt: any, email: string }, thread?: { __typename?: 'Thread', id: string, createdAt: any, updatedAt: any, name: string } | null, message?: { __typename?: 'Message', id: string, createdAt: any, updatedAt: any, content: string } | null } | null } | null> | null } };

export type MessageFragment = { __typename?: 'Message', id: string, createdAt: any, updatedAt: any, content: string, sentByAgent?: { __typename?: 'Agent', id: string, createdAt: any, updatedAt: any } | null, sentByUser?: { __typename?: 'User', id: string, createdAt: any, updatedAt: any, email: string } | null };

export type MessagesQueryVariables = Exact<{
  after?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MessageOrder> | MessageOrder>;
  where?: InputMaybe<MessageWhereInput>;
}>;


export type MessagesQuery = { __typename?: 'Query', messages: { __typename?: 'MessageConnection', totalCount: number, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean, startCursor?: any | null, endCursor?: any | null }, edges?: Array<{ __typename?: 'MessageEdge', cursor: any, node?: { __typename?: 'Message', id: string, createdAt: any, updatedAt: any, content: string, sentByAgent?: { __typename?: 'Agent', id: string, createdAt: any, updatedAt: any } | null, sentByUser?: { __typename?: 'User', id: string, createdAt: any, updatedAt: any, email: string } | null } | null } | null> | null } };

export type MessageQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type MessageQuery = { __typename?: 'Query', messages: { __typename?: 'MessageConnection', edges?: Array<{ __typename?: 'MessageEdge', node?: { __typename?: 'Message', id: string, createdAt: any, updatedAt: any, content: string, sentByAgent?: { __typename?: 'Agent', id: string, createdAt: any, updatedAt: any } | null, sentByUser?: { __typename?: 'User', id: string, createdAt: any, updatedAt: any, email: string } | null } | null } | null> | null } };

export type CreateMessageMutationVariables = Exact<{
  input: CreateMessageInput;
}>;


export type CreateMessageMutation = { __typename?: 'Mutation', createMessage?: { __typename?: 'Message', id: string } | null };

export type ThreadMessagesQueryVariables = Exact<{
  after?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MessageOrder> | MessageOrder>;
  threadId: Scalars['ID']['input'];
  userId: Scalars['ID']['input'];
}>;


export type ThreadMessagesQuery = { __typename?: 'Query', messages: { __typename?: 'MessageConnection', totalCount: number, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean, startCursor?: any | null, endCursor?: any | null }, edges?: Array<{ __typename?: 'MessageEdge', cursor: any, node?: { __typename?: 'Message', id: string, createdAt: any, updatedAt: any, content: string, sentByAgent?: { __typename?: 'Agent', id: string, createdAt: any, updatedAt: any } | null, sentByUser?: { __typename?: 'User', id: string, createdAt: any, updatedAt: any, email: string } | null, bookmarks: { __typename?: 'BookmarkConnection', edges?: Array<{ __typename?: 'BookmarkEdge', node?: { __typename?: 'Bookmark', id: string, createdAt: any, updatedAt: any, user: { __typename?: 'User', id: string, createdAt: any, updatedAt: any, email: string }, thread?: { __typename?: 'Thread', id: string, createdAt: any, updatedAt: any, name: string } | null, message?: { __typename?: 'Message', id: string, createdAt: any, updatedAt: any, content: string } | null } | null } | null> | null } } | null } | null> | null } };

export type ThreadMessageQueryVariables = Exact<{
  id: Scalars['ID']['input'];
  userId: Scalars['ID']['input'];
}>;


export type ThreadMessageQuery = { __typename?: 'Query', messages: { __typename?: 'MessageConnection', totalCount: number, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean, startCursor?: any | null, endCursor?: any | null }, edges?: Array<{ __typename?: 'MessageEdge', cursor: any, node?: { __typename?: 'Message', id: string, createdAt: any, updatedAt: any, content: string, sentByAgent?: { __typename?: 'Agent', id: string, createdAt: any, updatedAt: any } | null, sentByUser?: { __typename?: 'User', id: string, createdAt: any, updatedAt: any, email: string } | null, bookmarks: { __typename?: 'BookmarkConnection', edges?: Array<{ __typename?: 'BookmarkEdge', node?: { __typename?: 'Bookmark', id: string, createdAt: any, updatedAt: any, user: { __typename?: 'User', id: string, createdAt: any, updatedAt: any, email: string }, thread?: { __typename?: 'Thread', id: string, createdAt: any, updatedAt: any, name: string } | null, message?: { __typename?: 'Message', id: string, createdAt: any, updatedAt: any, content: string } | null } | null } | null> | null } } | null } | null> | null } };

export type ThreadFragment = { __typename?: 'Thread', id: string, createdAt: any, updatedAt: any, name: string, parent?: { __typename?: 'Thread', id: string, createdAt: any, updatedAt: any, name: string } | null, child?: { __typename?: 'Thread', id: string, createdAt: any, updatedAt: any, name: string } | null };

export type ThreadsQueryVariables = Exact<{
  after?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ThreadOrder> | ThreadOrder>;
  where?: InputMaybe<ThreadWhereInput>;
}>;


export type ThreadsQuery = { __typename?: 'Query', threads: { __typename?: 'ThreadConnection', totalCount: number, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean, startCursor?: any | null, endCursor?: any | null }, edges?: Array<{ __typename?: 'ThreadEdge', cursor: any, node?: { __typename?: 'Thread', id: string, createdAt: any, updatedAt: any, name: string, parent?: { __typename?: 'Thread', id: string, createdAt: any, updatedAt: any, name: string } | null, child?: { __typename?: 'Thread', id: string, createdAt: any, updatedAt: any, name: string } | null } | null } | null> | null } };

export type ThreadQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type ThreadQuery = { __typename?: 'Query', threads: { __typename?: 'ThreadConnection', edges?: Array<{ __typename?: 'ThreadEdge', node?: { __typename?: 'Thread', id: string, createdAt: any, updatedAt: any, name: string, parent?: { __typename?: 'Thread', id: string, createdAt: any, updatedAt: any, name: string } | null, child?: { __typename?: 'Thread', id: string, createdAt: any, updatedAt: any, name: string } | null } | null } | null> | null } };

export type CreateThreadMutationVariables = Exact<{
  input: CreateThreadInput;
}>;


export type CreateThreadMutation = { __typename?: 'Mutation', createThread?: { __typename?: 'Thread', id: string } | null };

export const BookmarkFragmentDoc = gql`
    fragment Bookmark on Bookmark {
  id
  createdAt
  updatedAt
  user {
    id
    createdAt
    updatedAt
    email
  }
  thread {
    id
    createdAt
    updatedAt
    name
  }
  message {
    id
    createdAt
    updatedAt
    content
  }
}
    `;
export const ThreadMessageFragmentDoc = gql`
    fragment ThreadMessage on Message {
  id
  createdAt
  updatedAt
  content
  sentByAgent {
    id
    createdAt
    updatedAt
  }
  sentByUser {
    id
    createdAt
    updatedAt
    email
  }
  bookmarks(where: {hasUserWith: {id: $userId}}) {
    edges {
      node {
        ...Bookmark
      }
    }
  }
}
    ${BookmarkFragmentDoc}`;
export const MessageFragmentDoc = gql`
    fragment Message on Message {
  id
  createdAt
  updatedAt
  content
  sentByAgent {
    id
    createdAt
    updatedAt
  }
  sentByUser {
    id
    createdAt
    updatedAt
    email
  }
}
    `;
export const ThreadFragmentDoc = gql`
    fragment Thread on Thread {
  id
  createdAt
  updatedAt
  name
  parent {
    id
    createdAt
    updatedAt
    name
  }
  child {
    id
    createdAt
    updatedAt
    name
  }
}
    `;
export const BookmarksDocument = gql`
    query bookmarks($after: Cursor, $first: Int, $before: Cursor, $last: Int, $orderBy: [BookmarkOrder!], $where: BookmarkWhereInput) {
  bookmarks(
    after: $after
    first: $first
    before: $before
    last: $last
    orderBy: $orderBy
    where: $where
  ) {
    totalCount
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    edges {
      node {
        ...Bookmark
      }
      cursor
    }
  }
}
    ${BookmarkFragmentDoc}`;
export const BookmarkDocument = gql`
    query bookmark($id: ID!) {
  bookmarks(where: {id: $id}) {
    edges {
      node {
        ...Bookmark
      }
    }
  }
}
    ${BookmarkFragmentDoc}`;
export const CreateBookmarkDocument = gql`
    mutation createBookmark($input: CreateBookmarkInput!) {
  createBookmark(input: $input) {
    id
  }
}
    `;
export const DeleteBookmarkDocument = gql`
    mutation deleteBookmark($id: ID!) {
  deleteBookmark(id: $id)
}
    `;
export const MessagesDocument = gql`
    query messages($after: Cursor, $first: Int, $before: Cursor, $last: Int, $orderBy: [MessageOrder!], $where: MessageWhereInput) {
  messages(
    after: $after
    first: $first
    before: $before
    last: $last
    orderBy: $orderBy
    where: $where
  ) {
    totalCount
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    edges {
      node {
        ...Message
      }
      cursor
    }
  }
}
    ${MessageFragmentDoc}`;
export const MessageDocument = gql`
    query message($id: ID!) {
  messages(where: {id: $id}) {
    edges {
      node {
        ...Message
      }
    }
  }
}
    ${MessageFragmentDoc}`;
export const CreateMessageDocument = gql`
    mutation createMessage($input: CreateMessageInput!) {
  createMessage(input: $input) {
    id
  }
}
    `;
export const ThreadMessagesDocument = gql`
    query threadMessages($after: Cursor, $first: Int, $before: Cursor, $last: Int, $orderBy: [MessageOrder!], $threadId: ID!, $userId: ID!) {
  messages(
    after: $after
    first: $first
    before: $before
    last: $last
    orderBy: $orderBy
    where: {hasThreadWith: {id: $threadId}}
  ) {
    totalCount
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    edges {
      node {
        ...ThreadMessage
      }
      cursor
    }
  }
}
    ${ThreadMessageFragmentDoc}`;
export const ThreadMessageDocument = gql`
    query threadMessage($id: ID!, $userId: ID!) {
  messages(where: {id: $id}) {
    totalCount
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    edges {
      node {
        ...ThreadMessage
      }
      cursor
    }
  }
}
    ${ThreadMessageFragmentDoc}`;
export const ThreadsDocument = gql`
    query threads($after: Cursor, $first: Int, $before: Cursor, $last: Int, $orderBy: [ThreadOrder!], $where: ThreadWhereInput) {
  threads(
    after: $after
    first: $first
    before: $before
    last: $last
    orderBy: $orderBy
    where: $where
  ) {
    totalCount
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    edges {
      node {
        ...Thread
      }
      cursor
    }
  }
}
    ${ThreadFragmentDoc}`;
export const ThreadDocument = gql`
    query thread($id: ID!) {
  threads(where: {id: $id}) {
    edges {
      node {
        ...Thread
      }
    }
  }
}
    ${ThreadFragmentDoc}`;
export const CreateThreadDocument = gql`
    mutation createThread($input: CreateThreadInput!) {
  createThread(input: $input) {
    id
  }
}
    `;

export type SdkFunctionWrapper = <T>(action: (requestHeaders?:Record<string, string>) => Promise<T>, operationName: string, operationType?: string, variables?: any) => Promise<T>;


const defaultWrapper: SdkFunctionWrapper = (action, _operationName, _operationType, _variables) => action();

export function getSdk(client: GraphQLClient, withWrapper: SdkFunctionWrapper = defaultWrapper) {
  return {
    bookmarks(variables?: BookmarksQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<BookmarksQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<BookmarksQuery>(BookmarksDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'bookmarks', 'query', variables);
    },
    bookmark(variables: BookmarkQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<BookmarkQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<BookmarkQuery>(BookmarkDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'bookmark', 'query', variables);
    },
    createBookmark(variables: CreateBookmarkMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<CreateBookmarkMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<CreateBookmarkMutation>(CreateBookmarkDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'createBookmark', 'mutation', variables);
    },
    deleteBookmark(variables: DeleteBookmarkMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<DeleteBookmarkMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<DeleteBookmarkMutation>(DeleteBookmarkDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'deleteBookmark', 'mutation', variables);
    },
    messages(variables?: MessagesQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<MessagesQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<MessagesQuery>(MessagesDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'messages', 'query', variables);
    },
    message(variables: MessageQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<MessageQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<MessageQuery>(MessageDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'message', 'query', variables);
    },
    createMessage(variables: CreateMessageMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<CreateMessageMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<CreateMessageMutation>(CreateMessageDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'createMessage', 'mutation', variables);
    },
    threadMessages(variables: ThreadMessagesQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<ThreadMessagesQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<ThreadMessagesQuery>(ThreadMessagesDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'threadMessages', 'query', variables);
    },
    threadMessage(variables: ThreadMessageQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<ThreadMessageQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<ThreadMessageQuery>(ThreadMessageDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'threadMessage', 'query', variables);
    },
    threads(variables?: ThreadsQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<ThreadsQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<ThreadsQuery>(ThreadsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'threads', 'query', variables);
    },
    thread(variables: ThreadQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<ThreadQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<ThreadQuery>(ThreadDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'thread', 'query', variables);
    },
    createThread(variables: CreateThreadMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<CreateThreadMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<CreateThreadMutation>(CreateThreadDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'createThread', 'mutation', variables);
    }
  };
}
export type Sdk = ReturnType<typeof getSdk>;