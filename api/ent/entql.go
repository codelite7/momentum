// Code generated by ent, DO NOT EDIT.

package ent

import (
	"github.com/codelite7/momentum/api/ent/agent"
	"github.com/codelite7/momentum/api/ent/bookmark"
	"github.com/codelite7/momentum/api/ent/message"
	"github.com/codelite7/momentum/api/ent/predicate"
	"github.com/codelite7/momentum/api/ent/response"
	"github.com/codelite7/momentum/api/ent/tenant"
	"github.com/codelite7/momentum/api/ent/thread"
	"github.com/codelite7/momentum/api/ent/user"
	"github.com/codelite7/momentum/api/ent/workoseventcursor"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/entql"
	"entgo.io/ent/schema/field"
)

// schemaGraph holds a representation of ent/schema at runtime.
var schemaGraph = func() *sqlgraph.Schema {
	graph := &sqlgraph.Schema{Nodes: make([]*sqlgraph.Node, 8)}
	graph.Nodes[0] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   agent.Table,
			Columns: agent.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeString,
				Column: agent.FieldID,
			},
		},
		Type: "Agent",
		Fields: map[string]*sqlgraph.FieldSpec{
			agent.FieldCreatedAt: {Type: field.TypeTime, Column: agent.FieldCreatedAt},
			agent.FieldUpdatedAt: {Type: field.TypeTime, Column: agent.FieldUpdatedAt},
			agent.FieldProvider:  {Type: field.TypeString, Column: agent.FieldProvider},
			agent.FieldModel:     {Type: field.TypeString, Column: agent.FieldModel},
			agent.FieldAPIKey:    {Type: field.TypeString, Column: agent.FieldAPIKey},
		},
	}
	graph.Nodes[1] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   bookmark.Table,
			Columns: bookmark.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeString,
				Column: bookmark.FieldID,
			},
		},
		Type: "Bookmark",
		Fields: map[string]*sqlgraph.FieldSpec{
			bookmark.FieldCreatedAt: {Type: field.TypeTime, Column: bookmark.FieldCreatedAt},
			bookmark.FieldUpdatedAt: {Type: field.TypeTime, Column: bookmark.FieldUpdatedAt},
			bookmark.FieldTenantID:  {Type: field.TypeString, Column: bookmark.FieldTenantID},
		},
	}
	graph.Nodes[2] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   message.Table,
			Columns: message.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeString,
				Column: message.FieldID,
			},
		},
		Type: "Message",
		Fields: map[string]*sqlgraph.FieldSpec{
			message.FieldCreatedAt: {Type: field.TypeTime, Column: message.FieldCreatedAt},
			message.FieldUpdatedAt: {Type: field.TypeTime, Column: message.FieldUpdatedAt},
			message.FieldTenantID:  {Type: field.TypeString, Column: message.FieldTenantID},
			message.FieldContent:   {Type: field.TypeString, Column: message.FieldContent},
		},
	}
	graph.Nodes[3] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   response.Table,
			Columns: response.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeString,
				Column: response.FieldID,
			},
		},
		Type: "Response",
		Fields: map[string]*sqlgraph.FieldSpec{
			response.FieldCreatedAt: {Type: field.TypeTime, Column: response.FieldCreatedAt},
			response.FieldUpdatedAt: {Type: field.TypeTime, Column: response.FieldUpdatedAt},
			response.FieldTenantID:  {Type: field.TypeString, Column: response.FieldTenantID},
			response.FieldContent:   {Type: field.TypeString, Column: response.FieldContent},
		},
	}
	graph.Nodes[4] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   tenant.Table,
			Columns: tenant.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeString,
				Column: tenant.FieldID,
			},
		},
		Type: "Tenant",
		Fields: map[string]*sqlgraph.FieldSpec{
			tenant.FieldCreatedAt:   {Type: field.TypeTime, Column: tenant.FieldCreatedAt},
			tenant.FieldUpdatedAt:   {Type: field.TypeTime, Column: tenant.FieldUpdatedAt},
			tenant.FieldWorkosOrgID: {Type: field.TypeString, Column: tenant.FieldWorkosOrgID},
		},
	}
	graph.Nodes[5] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   thread.Table,
			Columns: thread.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeString,
				Column: thread.FieldID,
			},
		},
		Type: "Thread",
		Fields: map[string]*sqlgraph.FieldSpec{
			thread.FieldCreatedAt:    {Type: field.TypeTime, Column: thread.FieldCreatedAt},
			thread.FieldUpdatedAt:    {Type: field.TypeTime, Column: thread.FieldUpdatedAt},
			thread.FieldTenantID:     {Type: field.TypeString, Column: thread.FieldTenantID},
			thread.FieldName:         {Type: field.TypeString, Column: thread.FieldName},
			thread.FieldLastViewedAt: {Type: field.TypeTime, Column: thread.FieldLastViewedAt},
		},
	}
	graph.Nodes[6] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   user.Table,
			Columns: user.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeString,
				Column: user.FieldID,
			},
		},
		Type: "User",
		Fields: map[string]*sqlgraph.FieldSpec{
			user.FieldCreatedAt:    {Type: field.TypeTime, Column: user.FieldCreatedAt},
			user.FieldUpdatedAt:    {Type: field.TypeTime, Column: user.FieldUpdatedAt},
			user.FieldEmail:        {Type: field.TypeString, Column: user.FieldEmail},
			user.FieldWorkosUserID: {Type: field.TypeString, Column: user.FieldWorkosUserID},
		},
	}
	graph.Nodes[7] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   workoseventcursor.Table,
			Columns: workoseventcursor.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: workoseventcursor.FieldID,
			},
		},
		Type: "WorkosEventCursor",
		Fields: map[string]*sqlgraph.FieldSpec{
			workoseventcursor.FieldUserCreatedCursor: {Type: field.TypeString, Column: workoseventcursor.FieldUserCreatedCursor},
		},
	}
	graph.MustAddE(
		"responses",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   agent.ResponsesTable,
			Columns: []string{agent.ResponsesColumn},
			Bidi:    false,
		},
		"Agent",
		"Response",
	)
	graph.MustAddE(
		"tenant",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   bookmark.TenantTable,
			Columns: []string{bookmark.TenantColumn},
			Bidi:    false,
		},
		"Bookmark",
		"Tenant",
	)
	graph.MustAddE(
		"user",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   bookmark.UserTable,
			Columns: []string{bookmark.UserColumn},
			Bidi:    false,
		},
		"Bookmark",
		"User",
	)
	graph.MustAddE(
		"thread",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   bookmark.ThreadTable,
			Columns: []string{bookmark.ThreadColumn},
			Bidi:    false,
		},
		"Bookmark",
		"Thread",
	)
	graph.MustAddE(
		"message",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   bookmark.MessageTable,
			Columns: []string{bookmark.MessageColumn},
			Bidi:    false,
		},
		"Bookmark",
		"Message",
	)
	graph.MustAddE(
		"response",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   bookmark.ResponseTable,
			Columns: []string{bookmark.ResponseColumn},
			Bidi:    false,
		},
		"Bookmark",
		"Response",
	)
	graph.MustAddE(
		"tenant",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   message.TenantTable,
			Columns: []string{message.TenantColumn},
			Bidi:    false,
		},
		"Message",
		"Tenant",
	)
	graph.MustAddE(
		"sent_by",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   message.SentByTable,
			Columns: []string{message.SentByColumn},
			Bidi:    false,
		},
		"Message",
		"User",
	)
	graph.MustAddE(
		"thread",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   message.ThreadTable,
			Columns: []string{message.ThreadColumn},
			Bidi:    false,
		},
		"Message",
		"Thread",
	)
	graph.MustAddE(
		"bookmarks",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   message.BookmarksTable,
			Columns: []string{message.BookmarksColumn},
			Bidi:    false,
		},
		"Message",
		"Bookmark",
	)
	graph.MustAddE(
		"response",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: false,
			Table:   message.ResponseTable,
			Columns: []string{message.ResponseColumn},
			Bidi:    false,
		},
		"Message",
		"Response",
	)
	graph.MustAddE(
		"tenant",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   response.TenantTable,
			Columns: []string{response.TenantColumn},
			Bidi:    false,
		},
		"Response",
		"Tenant",
	)
	graph.MustAddE(
		"sent_by",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   response.SentByTable,
			Columns: []string{response.SentByColumn},
			Bidi:    false,
		},
		"Response",
		"Agent",
	)
	graph.MustAddE(
		"message",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: true,
			Table:   response.MessageTable,
			Columns: []string{response.MessageColumn},
			Bidi:    false,
		},
		"Response",
		"Message",
	)
	graph.MustAddE(
		"bookmarks",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   response.BookmarksTable,
			Columns: []string{response.BookmarksColumn},
			Bidi:    false,
		},
		"Response",
		"Bookmark",
	)
	graph.MustAddE(
		"users",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   tenant.UsersTable,
			Columns: tenant.UsersPrimaryKey,
			Bidi:    false,
		},
		"Tenant",
		"User",
	)
	graph.MustAddE(
		"tenant",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   thread.TenantTable,
			Columns: []string{thread.TenantColumn},
			Bidi:    false,
		},
		"Thread",
		"Tenant",
	)
	graph.MustAddE(
		"created_by",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   thread.CreatedByTable,
			Columns: []string{thread.CreatedByColumn},
			Bidi:    false,
		},
		"Thread",
		"User",
	)
	graph.MustAddE(
		"messages",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   thread.MessagesTable,
			Columns: []string{thread.MessagesColumn},
			Bidi:    false,
		},
		"Thread",
		"Message",
	)
	graph.MustAddE(
		"bookmarks",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   thread.BookmarksTable,
			Columns: []string{thread.BookmarksColumn},
			Bidi:    false,
		},
		"Thread",
		"Bookmark",
	)
	graph.MustAddE(
		"parent",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   thread.ParentTable,
			Columns: []string{thread.ParentColumn},
			Bidi:    false,
		},
		"Thread",
		"Thread",
	)
	graph.MustAddE(
		"children",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   thread.ChildrenTable,
			Columns: []string{thread.ChildrenColumn},
			Bidi:    false,
		},
		"Thread",
		"Thread",
	)
	graph.MustAddE(
		"bookmarks",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.BookmarksTable,
			Columns: []string{user.BookmarksColumn},
			Bidi:    false,
		},
		"User",
		"Bookmark",
	)
	graph.MustAddE(
		"threads",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.ThreadsTable,
			Columns: []string{user.ThreadsColumn},
			Bidi:    false,
		},
		"User",
		"Thread",
	)
	graph.MustAddE(
		"messages",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.MessagesTable,
			Columns: []string{user.MessagesColumn},
			Bidi:    false,
		},
		"User",
		"Message",
	)
	graph.MustAddE(
		"tenants",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   user.TenantsTable,
			Columns: user.TenantsPrimaryKey,
			Bidi:    false,
		},
		"User",
		"Tenant",
	)
	graph.MustAddE(
		"active_tenant",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   user.ActiveTenantTable,
			Columns: []string{user.ActiveTenantColumn},
			Bidi:    false,
		},
		"User",
		"Tenant",
	)
	return graph
}()

// predicateAdder wraps the addPredicate method.
// All update, update-one and query builders implement this interface.
type predicateAdder interface {
	addPredicate(func(s *sql.Selector))
}

// addPredicate implements the predicateAdder interface.
func (aq *AgentQuery) addPredicate(pred func(s *sql.Selector)) {
	aq.predicates = append(aq.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the AgentQuery builder.
func (aq *AgentQuery) Filter() *AgentFilter {
	return &AgentFilter{config: aq.config, predicateAdder: aq}
}

// addPredicate implements the predicateAdder interface.
func (m *AgentMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the AgentMutation builder.
func (m *AgentMutation) Filter() *AgentFilter {
	return &AgentFilter{config: m.config, predicateAdder: m}
}

// AgentFilter provides a generic filtering capability at runtime for AgentQuery.
type AgentFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *AgentFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[0].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql string predicate on the id field.
func (f *AgentFilter) WhereID(p entql.StringP) {
	f.Where(p.Field(agent.FieldID))
}

// WhereCreatedAt applies the entql time.Time predicate on the created_at field.
func (f *AgentFilter) WhereCreatedAt(p entql.TimeP) {
	f.Where(p.Field(agent.FieldCreatedAt))
}

// WhereUpdatedAt applies the entql time.Time predicate on the updated_at field.
func (f *AgentFilter) WhereUpdatedAt(p entql.TimeP) {
	f.Where(p.Field(agent.FieldUpdatedAt))
}

// WhereProvider applies the entql string predicate on the provider field.
func (f *AgentFilter) WhereProvider(p entql.StringP) {
	f.Where(p.Field(agent.FieldProvider))
}

// WhereModel applies the entql string predicate on the model field.
func (f *AgentFilter) WhereModel(p entql.StringP) {
	f.Where(p.Field(agent.FieldModel))
}

// WhereAPIKey applies the entql string predicate on the api_key field.
func (f *AgentFilter) WhereAPIKey(p entql.StringP) {
	f.Where(p.Field(agent.FieldAPIKey))
}

// WhereHasResponses applies a predicate to check if query has an edge responses.
func (f *AgentFilter) WhereHasResponses() {
	f.Where(entql.HasEdge("responses"))
}

// WhereHasResponsesWith applies a predicate to check if query has an edge responses with a given conditions (other predicates).
func (f *AgentFilter) WhereHasResponsesWith(preds ...predicate.Response) {
	f.Where(entql.HasEdgeWith("responses", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (bq *BookmarkQuery) addPredicate(pred func(s *sql.Selector)) {
	bq.predicates = append(bq.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the BookmarkQuery builder.
func (bq *BookmarkQuery) Filter() *BookmarkFilter {
	return &BookmarkFilter{config: bq.config, predicateAdder: bq}
}

// addPredicate implements the predicateAdder interface.
func (m *BookmarkMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the BookmarkMutation builder.
func (m *BookmarkMutation) Filter() *BookmarkFilter {
	return &BookmarkFilter{config: m.config, predicateAdder: m}
}

// BookmarkFilter provides a generic filtering capability at runtime for BookmarkQuery.
type BookmarkFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *BookmarkFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[1].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql string predicate on the id field.
func (f *BookmarkFilter) WhereID(p entql.StringP) {
	f.Where(p.Field(bookmark.FieldID))
}

// WhereCreatedAt applies the entql time.Time predicate on the created_at field.
func (f *BookmarkFilter) WhereCreatedAt(p entql.TimeP) {
	f.Where(p.Field(bookmark.FieldCreatedAt))
}

// WhereUpdatedAt applies the entql time.Time predicate on the updated_at field.
func (f *BookmarkFilter) WhereUpdatedAt(p entql.TimeP) {
	f.Where(p.Field(bookmark.FieldUpdatedAt))
}

// WhereTenantID applies the entql string predicate on the tenant_id field.
func (f *BookmarkFilter) WhereTenantID(p entql.StringP) {
	f.Where(p.Field(bookmark.FieldTenantID))
}

// WhereHasTenant applies a predicate to check if query has an edge tenant.
func (f *BookmarkFilter) WhereHasTenant() {
	f.Where(entql.HasEdge("tenant"))
}

// WhereHasTenantWith applies a predicate to check if query has an edge tenant with a given conditions (other predicates).
func (f *BookmarkFilter) WhereHasTenantWith(preds ...predicate.Tenant) {
	f.Where(entql.HasEdgeWith("tenant", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasUser applies a predicate to check if query has an edge user.
func (f *BookmarkFilter) WhereHasUser() {
	f.Where(entql.HasEdge("user"))
}

// WhereHasUserWith applies a predicate to check if query has an edge user with a given conditions (other predicates).
func (f *BookmarkFilter) WhereHasUserWith(preds ...predicate.User) {
	f.Where(entql.HasEdgeWith("user", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasThread applies a predicate to check if query has an edge thread.
func (f *BookmarkFilter) WhereHasThread() {
	f.Where(entql.HasEdge("thread"))
}

// WhereHasThreadWith applies a predicate to check if query has an edge thread with a given conditions (other predicates).
func (f *BookmarkFilter) WhereHasThreadWith(preds ...predicate.Thread) {
	f.Where(entql.HasEdgeWith("thread", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasMessage applies a predicate to check if query has an edge message.
func (f *BookmarkFilter) WhereHasMessage() {
	f.Where(entql.HasEdge("message"))
}

// WhereHasMessageWith applies a predicate to check if query has an edge message with a given conditions (other predicates).
func (f *BookmarkFilter) WhereHasMessageWith(preds ...predicate.Message) {
	f.Where(entql.HasEdgeWith("message", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasResponse applies a predicate to check if query has an edge response.
func (f *BookmarkFilter) WhereHasResponse() {
	f.Where(entql.HasEdge("response"))
}

// WhereHasResponseWith applies a predicate to check if query has an edge response with a given conditions (other predicates).
func (f *BookmarkFilter) WhereHasResponseWith(preds ...predicate.Response) {
	f.Where(entql.HasEdgeWith("response", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (mq *MessageQuery) addPredicate(pred func(s *sql.Selector)) {
	mq.predicates = append(mq.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the MessageQuery builder.
func (mq *MessageQuery) Filter() *MessageFilter {
	return &MessageFilter{config: mq.config, predicateAdder: mq}
}

// addPredicate implements the predicateAdder interface.
func (m *MessageMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the MessageMutation builder.
func (m *MessageMutation) Filter() *MessageFilter {
	return &MessageFilter{config: m.config, predicateAdder: m}
}

// MessageFilter provides a generic filtering capability at runtime for MessageQuery.
type MessageFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *MessageFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[2].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql string predicate on the id field.
func (f *MessageFilter) WhereID(p entql.StringP) {
	f.Where(p.Field(message.FieldID))
}

// WhereCreatedAt applies the entql time.Time predicate on the created_at field.
func (f *MessageFilter) WhereCreatedAt(p entql.TimeP) {
	f.Where(p.Field(message.FieldCreatedAt))
}

// WhereUpdatedAt applies the entql time.Time predicate on the updated_at field.
func (f *MessageFilter) WhereUpdatedAt(p entql.TimeP) {
	f.Where(p.Field(message.FieldUpdatedAt))
}

// WhereTenantID applies the entql string predicate on the tenant_id field.
func (f *MessageFilter) WhereTenantID(p entql.StringP) {
	f.Where(p.Field(message.FieldTenantID))
}

// WhereContent applies the entql string predicate on the content field.
func (f *MessageFilter) WhereContent(p entql.StringP) {
	f.Where(p.Field(message.FieldContent))
}

// WhereHasTenant applies a predicate to check if query has an edge tenant.
func (f *MessageFilter) WhereHasTenant() {
	f.Where(entql.HasEdge("tenant"))
}

// WhereHasTenantWith applies a predicate to check if query has an edge tenant with a given conditions (other predicates).
func (f *MessageFilter) WhereHasTenantWith(preds ...predicate.Tenant) {
	f.Where(entql.HasEdgeWith("tenant", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasSentBy applies a predicate to check if query has an edge sent_by.
func (f *MessageFilter) WhereHasSentBy() {
	f.Where(entql.HasEdge("sent_by"))
}

// WhereHasSentByWith applies a predicate to check if query has an edge sent_by with a given conditions (other predicates).
func (f *MessageFilter) WhereHasSentByWith(preds ...predicate.User) {
	f.Where(entql.HasEdgeWith("sent_by", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasThread applies a predicate to check if query has an edge thread.
func (f *MessageFilter) WhereHasThread() {
	f.Where(entql.HasEdge("thread"))
}

// WhereHasThreadWith applies a predicate to check if query has an edge thread with a given conditions (other predicates).
func (f *MessageFilter) WhereHasThreadWith(preds ...predicate.Thread) {
	f.Where(entql.HasEdgeWith("thread", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasBookmarks applies a predicate to check if query has an edge bookmarks.
func (f *MessageFilter) WhereHasBookmarks() {
	f.Where(entql.HasEdge("bookmarks"))
}

// WhereHasBookmarksWith applies a predicate to check if query has an edge bookmarks with a given conditions (other predicates).
func (f *MessageFilter) WhereHasBookmarksWith(preds ...predicate.Bookmark) {
	f.Where(entql.HasEdgeWith("bookmarks", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasResponse applies a predicate to check if query has an edge response.
func (f *MessageFilter) WhereHasResponse() {
	f.Where(entql.HasEdge("response"))
}

// WhereHasResponseWith applies a predicate to check if query has an edge response with a given conditions (other predicates).
func (f *MessageFilter) WhereHasResponseWith(preds ...predicate.Response) {
	f.Where(entql.HasEdgeWith("response", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (rq *ResponseQuery) addPredicate(pred func(s *sql.Selector)) {
	rq.predicates = append(rq.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the ResponseQuery builder.
func (rq *ResponseQuery) Filter() *ResponseFilter {
	return &ResponseFilter{config: rq.config, predicateAdder: rq}
}

// addPredicate implements the predicateAdder interface.
func (m *ResponseMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the ResponseMutation builder.
func (m *ResponseMutation) Filter() *ResponseFilter {
	return &ResponseFilter{config: m.config, predicateAdder: m}
}

// ResponseFilter provides a generic filtering capability at runtime for ResponseQuery.
type ResponseFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *ResponseFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[3].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql string predicate on the id field.
func (f *ResponseFilter) WhereID(p entql.StringP) {
	f.Where(p.Field(response.FieldID))
}

// WhereCreatedAt applies the entql time.Time predicate on the created_at field.
func (f *ResponseFilter) WhereCreatedAt(p entql.TimeP) {
	f.Where(p.Field(response.FieldCreatedAt))
}

// WhereUpdatedAt applies the entql time.Time predicate on the updated_at field.
func (f *ResponseFilter) WhereUpdatedAt(p entql.TimeP) {
	f.Where(p.Field(response.FieldUpdatedAt))
}

// WhereTenantID applies the entql string predicate on the tenant_id field.
func (f *ResponseFilter) WhereTenantID(p entql.StringP) {
	f.Where(p.Field(response.FieldTenantID))
}

// WhereContent applies the entql string predicate on the content field.
func (f *ResponseFilter) WhereContent(p entql.StringP) {
	f.Where(p.Field(response.FieldContent))
}

// WhereHasTenant applies a predicate to check if query has an edge tenant.
func (f *ResponseFilter) WhereHasTenant() {
	f.Where(entql.HasEdge("tenant"))
}

// WhereHasTenantWith applies a predicate to check if query has an edge tenant with a given conditions (other predicates).
func (f *ResponseFilter) WhereHasTenantWith(preds ...predicate.Tenant) {
	f.Where(entql.HasEdgeWith("tenant", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasSentBy applies a predicate to check if query has an edge sent_by.
func (f *ResponseFilter) WhereHasSentBy() {
	f.Where(entql.HasEdge("sent_by"))
}

// WhereHasSentByWith applies a predicate to check if query has an edge sent_by with a given conditions (other predicates).
func (f *ResponseFilter) WhereHasSentByWith(preds ...predicate.Agent) {
	f.Where(entql.HasEdgeWith("sent_by", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasMessage applies a predicate to check if query has an edge message.
func (f *ResponseFilter) WhereHasMessage() {
	f.Where(entql.HasEdge("message"))
}

// WhereHasMessageWith applies a predicate to check if query has an edge message with a given conditions (other predicates).
func (f *ResponseFilter) WhereHasMessageWith(preds ...predicate.Message) {
	f.Where(entql.HasEdgeWith("message", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasBookmarks applies a predicate to check if query has an edge bookmarks.
func (f *ResponseFilter) WhereHasBookmarks() {
	f.Where(entql.HasEdge("bookmarks"))
}

// WhereHasBookmarksWith applies a predicate to check if query has an edge bookmarks with a given conditions (other predicates).
func (f *ResponseFilter) WhereHasBookmarksWith(preds ...predicate.Bookmark) {
	f.Where(entql.HasEdgeWith("bookmarks", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (tq *TenantQuery) addPredicate(pred func(s *sql.Selector)) {
	tq.predicates = append(tq.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the TenantQuery builder.
func (tq *TenantQuery) Filter() *TenantFilter {
	return &TenantFilter{config: tq.config, predicateAdder: tq}
}

// addPredicate implements the predicateAdder interface.
func (m *TenantMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the TenantMutation builder.
func (m *TenantMutation) Filter() *TenantFilter {
	return &TenantFilter{config: m.config, predicateAdder: m}
}

// TenantFilter provides a generic filtering capability at runtime for TenantQuery.
type TenantFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *TenantFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[4].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql string predicate on the id field.
func (f *TenantFilter) WhereID(p entql.StringP) {
	f.Where(p.Field(tenant.FieldID))
}

// WhereCreatedAt applies the entql time.Time predicate on the created_at field.
func (f *TenantFilter) WhereCreatedAt(p entql.TimeP) {
	f.Where(p.Field(tenant.FieldCreatedAt))
}

// WhereUpdatedAt applies the entql time.Time predicate on the updated_at field.
func (f *TenantFilter) WhereUpdatedAt(p entql.TimeP) {
	f.Where(p.Field(tenant.FieldUpdatedAt))
}

// WhereWorkosOrgID applies the entql string predicate on the workos_org_id field.
func (f *TenantFilter) WhereWorkosOrgID(p entql.StringP) {
	f.Where(p.Field(tenant.FieldWorkosOrgID))
}

// WhereHasUsers applies a predicate to check if query has an edge users.
func (f *TenantFilter) WhereHasUsers() {
	f.Where(entql.HasEdge("users"))
}

// WhereHasUsersWith applies a predicate to check if query has an edge users with a given conditions (other predicates).
func (f *TenantFilter) WhereHasUsersWith(preds ...predicate.User) {
	f.Where(entql.HasEdgeWith("users", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (tq *ThreadQuery) addPredicate(pred func(s *sql.Selector)) {
	tq.predicates = append(tq.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the ThreadQuery builder.
func (tq *ThreadQuery) Filter() *ThreadFilter {
	return &ThreadFilter{config: tq.config, predicateAdder: tq}
}

// addPredicate implements the predicateAdder interface.
func (m *ThreadMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the ThreadMutation builder.
func (m *ThreadMutation) Filter() *ThreadFilter {
	return &ThreadFilter{config: m.config, predicateAdder: m}
}

// ThreadFilter provides a generic filtering capability at runtime for ThreadQuery.
type ThreadFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *ThreadFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[5].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql string predicate on the id field.
func (f *ThreadFilter) WhereID(p entql.StringP) {
	f.Where(p.Field(thread.FieldID))
}

// WhereCreatedAt applies the entql time.Time predicate on the created_at field.
func (f *ThreadFilter) WhereCreatedAt(p entql.TimeP) {
	f.Where(p.Field(thread.FieldCreatedAt))
}

// WhereUpdatedAt applies the entql time.Time predicate on the updated_at field.
func (f *ThreadFilter) WhereUpdatedAt(p entql.TimeP) {
	f.Where(p.Field(thread.FieldUpdatedAt))
}

// WhereTenantID applies the entql string predicate on the tenant_id field.
func (f *ThreadFilter) WhereTenantID(p entql.StringP) {
	f.Where(p.Field(thread.FieldTenantID))
}

// WhereName applies the entql string predicate on the name field.
func (f *ThreadFilter) WhereName(p entql.StringP) {
	f.Where(p.Field(thread.FieldName))
}

// WhereLastViewedAt applies the entql time.Time predicate on the last_viewed_at field.
func (f *ThreadFilter) WhereLastViewedAt(p entql.TimeP) {
	f.Where(p.Field(thread.FieldLastViewedAt))
}

// WhereHasTenant applies a predicate to check if query has an edge tenant.
func (f *ThreadFilter) WhereHasTenant() {
	f.Where(entql.HasEdge("tenant"))
}

// WhereHasTenantWith applies a predicate to check if query has an edge tenant with a given conditions (other predicates).
func (f *ThreadFilter) WhereHasTenantWith(preds ...predicate.Tenant) {
	f.Where(entql.HasEdgeWith("tenant", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasCreatedBy applies a predicate to check if query has an edge created_by.
func (f *ThreadFilter) WhereHasCreatedBy() {
	f.Where(entql.HasEdge("created_by"))
}

// WhereHasCreatedByWith applies a predicate to check if query has an edge created_by with a given conditions (other predicates).
func (f *ThreadFilter) WhereHasCreatedByWith(preds ...predicate.User) {
	f.Where(entql.HasEdgeWith("created_by", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasMessages applies a predicate to check if query has an edge messages.
func (f *ThreadFilter) WhereHasMessages() {
	f.Where(entql.HasEdge("messages"))
}

// WhereHasMessagesWith applies a predicate to check if query has an edge messages with a given conditions (other predicates).
func (f *ThreadFilter) WhereHasMessagesWith(preds ...predicate.Message) {
	f.Where(entql.HasEdgeWith("messages", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasBookmarks applies a predicate to check if query has an edge bookmarks.
func (f *ThreadFilter) WhereHasBookmarks() {
	f.Where(entql.HasEdge("bookmarks"))
}

// WhereHasBookmarksWith applies a predicate to check if query has an edge bookmarks with a given conditions (other predicates).
func (f *ThreadFilter) WhereHasBookmarksWith(preds ...predicate.Bookmark) {
	f.Where(entql.HasEdgeWith("bookmarks", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasParent applies a predicate to check if query has an edge parent.
func (f *ThreadFilter) WhereHasParent() {
	f.Where(entql.HasEdge("parent"))
}

// WhereHasParentWith applies a predicate to check if query has an edge parent with a given conditions (other predicates).
func (f *ThreadFilter) WhereHasParentWith(preds ...predicate.Thread) {
	f.Where(entql.HasEdgeWith("parent", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasChildren applies a predicate to check if query has an edge children.
func (f *ThreadFilter) WhereHasChildren() {
	f.Where(entql.HasEdge("children"))
}

// WhereHasChildrenWith applies a predicate to check if query has an edge children with a given conditions (other predicates).
func (f *ThreadFilter) WhereHasChildrenWith(preds ...predicate.Thread) {
	f.Where(entql.HasEdgeWith("children", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (uq *UserQuery) addPredicate(pred func(s *sql.Selector)) {
	uq.predicates = append(uq.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the UserQuery builder.
func (uq *UserQuery) Filter() *UserFilter {
	return &UserFilter{config: uq.config, predicateAdder: uq}
}

// addPredicate implements the predicateAdder interface.
func (m *UserMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the UserMutation builder.
func (m *UserMutation) Filter() *UserFilter {
	return &UserFilter{config: m.config, predicateAdder: m}
}

// UserFilter provides a generic filtering capability at runtime for UserQuery.
type UserFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *UserFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[6].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql string predicate on the id field.
func (f *UserFilter) WhereID(p entql.StringP) {
	f.Where(p.Field(user.FieldID))
}

// WhereCreatedAt applies the entql time.Time predicate on the created_at field.
func (f *UserFilter) WhereCreatedAt(p entql.TimeP) {
	f.Where(p.Field(user.FieldCreatedAt))
}

// WhereUpdatedAt applies the entql time.Time predicate on the updated_at field.
func (f *UserFilter) WhereUpdatedAt(p entql.TimeP) {
	f.Where(p.Field(user.FieldUpdatedAt))
}

// WhereEmail applies the entql string predicate on the email field.
func (f *UserFilter) WhereEmail(p entql.StringP) {
	f.Where(p.Field(user.FieldEmail))
}

// WhereWorkosUserID applies the entql string predicate on the workos_user_id field.
func (f *UserFilter) WhereWorkosUserID(p entql.StringP) {
	f.Where(p.Field(user.FieldWorkosUserID))
}

// WhereHasBookmarks applies a predicate to check if query has an edge bookmarks.
func (f *UserFilter) WhereHasBookmarks() {
	f.Where(entql.HasEdge("bookmarks"))
}

// WhereHasBookmarksWith applies a predicate to check if query has an edge bookmarks with a given conditions (other predicates).
func (f *UserFilter) WhereHasBookmarksWith(preds ...predicate.Bookmark) {
	f.Where(entql.HasEdgeWith("bookmarks", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasThreads applies a predicate to check if query has an edge threads.
func (f *UserFilter) WhereHasThreads() {
	f.Where(entql.HasEdge("threads"))
}

// WhereHasThreadsWith applies a predicate to check if query has an edge threads with a given conditions (other predicates).
func (f *UserFilter) WhereHasThreadsWith(preds ...predicate.Thread) {
	f.Where(entql.HasEdgeWith("threads", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasMessages applies a predicate to check if query has an edge messages.
func (f *UserFilter) WhereHasMessages() {
	f.Where(entql.HasEdge("messages"))
}

// WhereHasMessagesWith applies a predicate to check if query has an edge messages with a given conditions (other predicates).
func (f *UserFilter) WhereHasMessagesWith(preds ...predicate.Message) {
	f.Where(entql.HasEdgeWith("messages", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasTenants applies a predicate to check if query has an edge tenants.
func (f *UserFilter) WhereHasTenants() {
	f.Where(entql.HasEdge("tenants"))
}

// WhereHasTenantsWith applies a predicate to check if query has an edge tenants with a given conditions (other predicates).
func (f *UserFilter) WhereHasTenantsWith(preds ...predicate.Tenant) {
	f.Where(entql.HasEdgeWith("tenants", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasActiveTenant applies a predicate to check if query has an edge active_tenant.
func (f *UserFilter) WhereHasActiveTenant() {
	f.Where(entql.HasEdge("active_tenant"))
}

// WhereHasActiveTenantWith applies a predicate to check if query has an edge active_tenant with a given conditions (other predicates).
func (f *UserFilter) WhereHasActiveTenantWith(preds ...predicate.Tenant) {
	f.Where(entql.HasEdgeWith("active_tenant", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (wecq *WorkosEventCursorQuery) addPredicate(pred func(s *sql.Selector)) {
	wecq.predicates = append(wecq.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the WorkosEventCursorQuery builder.
func (wecq *WorkosEventCursorQuery) Filter() *WorkosEventCursorFilter {
	return &WorkosEventCursorFilter{config: wecq.config, predicateAdder: wecq}
}

// addPredicate implements the predicateAdder interface.
func (m *WorkosEventCursorMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the WorkosEventCursorMutation builder.
func (m *WorkosEventCursorMutation) Filter() *WorkosEventCursorFilter {
	return &WorkosEventCursorFilter{config: m.config, predicateAdder: m}
}

// WorkosEventCursorFilter provides a generic filtering capability at runtime for WorkosEventCursorQuery.
type WorkosEventCursorFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *WorkosEventCursorFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[7].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql int predicate on the id field.
func (f *WorkosEventCursorFilter) WhereID(p entql.IntP) {
	f.Where(p.Field(workoseventcursor.FieldID))
}

// WhereUserCreatedCursor applies the entql string predicate on the user_created_cursor field.
func (f *WorkosEventCursorFilter) WhereUserCreatedCursor(p entql.StringP) {
	f.Where(p.Field(workoseventcursor.FieldUserCreatedCursor))
}
