// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package resolvers

import (
	"bytes"
	"context"
	"errors"
	"sync/atomic"

	"entgo.io/contrib/entgql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/codelite7/momentum/api/ent"
	"github.com/codelite7/momentum/api/ent/schema/pulid"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Agent struct {
		CreatedAt func(childComplexity int) int
		ID        func(childComplexity int) int
		Model     func(childComplexity int) int
		Provider  func(childComplexity int) int
		Responses func(childComplexity int, after *entgql.Cursor[pulid.ID], first *int, before *entgql.Cursor[pulid.ID], last *int, orderBy []*ent.ResponseOrder, where *ent.ResponseWhereInput) int
		UpdatedAt func(childComplexity int) int
	}

	AgentConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	AgentEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Bookmark struct {
		CreatedAt func(childComplexity int) int
		ID        func(childComplexity int) int
		Message   func(childComplexity int) int
		Response  func(childComplexity int) int
		Thread    func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
		User      func(childComplexity int) int
	}

	BookmarkConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	BookmarkEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Message struct {
		Bookmarks func(childComplexity int, after *entgql.Cursor[pulid.ID], first *int, before *entgql.Cursor[pulid.ID], last *int, orderBy []*ent.BookmarkOrder, where *ent.BookmarkWhereInput) int
		Content   func(childComplexity int) int
		CreatedAt func(childComplexity int) int
		ID        func(childComplexity int) int
		Response  func(childComplexity int) int
		SentBy    func(childComplexity int) int
		Thread    func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
	}

	MessageConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	MessageEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Mutation struct {
		CreateAgent    func(childComplexity int, input ent.CreateAgentInput) int
		CreateBookmark func(childComplexity int, input ent.CreateBookmarkInput) int
		CreateMessage  func(childComplexity int, input ent.CreateMessageInput) int
		CreateThread   func(childComplexity int, input ent.CreateThreadInput) int
		CreateUser     func(childComplexity int, input ent.CreateUserInput) int
		DeleteBookmark func(childComplexity int, id pulid.ID) int
		DeleteThread   func(childComplexity int, id pulid.ID) int
		UpdateThread   func(childComplexity int, id pulid.ID, input ent.UpdateThreadInput) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
	}

	Query struct {
		Agents    func(childComplexity int, after *entgql.Cursor[pulid.ID], first *int, before *entgql.Cursor[pulid.ID], last *int, orderBy []*ent.AgentOrder, where *ent.AgentWhereInput) int
		Bookmarks func(childComplexity int, after *entgql.Cursor[pulid.ID], first *int, before *entgql.Cursor[pulid.ID], last *int, orderBy []*ent.BookmarkOrder, where *ent.BookmarkWhereInput) int
		Messages  func(childComplexity int, after *entgql.Cursor[pulid.ID], first *int, before *entgql.Cursor[pulid.ID], last *int, orderBy []*ent.MessageOrder, where *ent.MessageWhereInput) int
		Node      func(childComplexity int, id pulid.ID) int
		Nodes     func(childComplexity int, ids []pulid.ID) int
		Responses func(childComplexity int, after *entgql.Cursor[pulid.ID], first *int, before *entgql.Cursor[pulid.ID], last *int, orderBy []*ent.ResponseOrder, where *ent.ResponseWhereInput) int
		Thread    func(childComplexity int, id pulid.ID) int
		Threads   func(childComplexity int, after *entgql.Cursor[pulid.ID], first *int, before *entgql.Cursor[pulid.ID], last *int, orderBy []*ent.ThreadOrder, where *ent.ThreadWhereInput) int
		User      func(childComplexity int) int
		Users     func(childComplexity int, after *entgql.Cursor[pulid.ID], first *int, before *entgql.Cursor[pulid.ID], last *int, orderBy []*ent.UserOrder, where *ent.UserWhereInput) int
	}

	Response struct {
		Bookmarks func(childComplexity int, after *entgql.Cursor[pulid.ID], first *int, before *entgql.Cursor[pulid.ID], last *int, orderBy []*ent.BookmarkOrder, where *ent.BookmarkWhereInput) int
		Content   func(childComplexity int) int
		CreatedAt func(childComplexity int) int
		ID        func(childComplexity int) int
		Message   func(childComplexity int) int
		SentBy    func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
	}

	ResponseConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	ResponseEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Thread struct {
		Bookmarks    func(childComplexity int, after *entgql.Cursor[pulid.ID], first *int, before *entgql.Cursor[pulid.ID], last *int, orderBy []*ent.BookmarkOrder, where *ent.BookmarkWhereInput) int
		Children     func(childComplexity int, after *entgql.Cursor[pulid.ID], first *int, before *entgql.Cursor[pulid.ID], last *int, orderBy []*ent.ThreadOrder, where *ent.ThreadWhereInput) int
		CreatedAt    func(childComplexity int) int
		CreatedBy    func(childComplexity int) int
		ID           func(childComplexity int) int
		LastViewedAt func(childComplexity int) int
		Messages     func(childComplexity int, after *entgql.Cursor[pulid.ID], first *int, before *entgql.Cursor[pulid.ID], last *int, orderBy []*ent.MessageOrder, where *ent.MessageWhereInput) int
		Name         func(childComplexity int) int
		Parent       func(childComplexity int) int
		UpdatedAt    func(childComplexity int) int
	}

	ThreadConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	ThreadEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	User struct {
		Bookmarks func(childComplexity int, after *entgql.Cursor[pulid.ID], first *int, before *entgql.Cursor[pulid.ID], last *int, orderBy []*ent.BookmarkOrder, where *ent.BookmarkWhereInput) int
		CreatedAt func(childComplexity int) int
		Email     func(childComplexity int) int
		ID        func(childComplexity int) int
		Messages  func(childComplexity int, after *entgql.Cursor[pulid.ID], first *int, before *entgql.Cursor[pulid.ID], last *int, orderBy []*ent.MessageOrder, where *ent.MessageWhereInput) int
		Threads   func(childComplexity int, after *entgql.Cursor[pulid.ID], first *int, before *entgql.Cursor[pulid.ID], last *int, orderBy []*ent.ThreadOrder, where *ent.ThreadWhereInput) int
		UpdatedAt func(childComplexity int) int
	}

	UserConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	UserEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Agent.createdAt":
		if e.complexity.Agent.CreatedAt == nil {
			break
		}

		return e.complexity.Agent.CreatedAt(childComplexity), true

	case "Agent.id":
		if e.complexity.Agent.ID == nil {
			break
		}

		return e.complexity.Agent.ID(childComplexity), true

	case "Agent.model":
		if e.complexity.Agent.Model == nil {
			break
		}

		return e.complexity.Agent.Model(childComplexity), true

	case "Agent.provider":
		if e.complexity.Agent.Provider == nil {
			break
		}

		return e.complexity.Agent.Provider(childComplexity), true

	case "Agent.responses":
		if e.complexity.Agent.Responses == nil {
			break
		}

		args, err := ec.field_Agent_responses_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Agent.Responses(childComplexity, args["after"].(*entgql.Cursor[pulid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[pulid.ID]), args["last"].(*int), args["orderBy"].([]*ent.ResponseOrder), args["where"].(*ent.ResponseWhereInput)), true

	case "Agent.updatedAt":
		if e.complexity.Agent.UpdatedAt == nil {
			break
		}

		return e.complexity.Agent.UpdatedAt(childComplexity), true

	case "AgentConnection.edges":
		if e.complexity.AgentConnection.Edges == nil {
			break
		}

		return e.complexity.AgentConnection.Edges(childComplexity), true

	case "AgentConnection.pageInfo":
		if e.complexity.AgentConnection.PageInfo == nil {
			break
		}

		return e.complexity.AgentConnection.PageInfo(childComplexity), true

	case "AgentConnection.totalCount":
		if e.complexity.AgentConnection.TotalCount == nil {
			break
		}

		return e.complexity.AgentConnection.TotalCount(childComplexity), true

	case "AgentEdge.cursor":
		if e.complexity.AgentEdge.Cursor == nil {
			break
		}

		return e.complexity.AgentEdge.Cursor(childComplexity), true

	case "AgentEdge.node":
		if e.complexity.AgentEdge.Node == nil {
			break
		}

		return e.complexity.AgentEdge.Node(childComplexity), true

	case "Bookmark.createdAt":
		if e.complexity.Bookmark.CreatedAt == nil {
			break
		}

		return e.complexity.Bookmark.CreatedAt(childComplexity), true

	case "Bookmark.id":
		if e.complexity.Bookmark.ID == nil {
			break
		}

		return e.complexity.Bookmark.ID(childComplexity), true

	case "Bookmark.message":
		if e.complexity.Bookmark.Message == nil {
			break
		}

		return e.complexity.Bookmark.Message(childComplexity), true

	case "Bookmark.response":
		if e.complexity.Bookmark.Response == nil {
			break
		}

		return e.complexity.Bookmark.Response(childComplexity), true

	case "Bookmark.thread":
		if e.complexity.Bookmark.Thread == nil {
			break
		}

		return e.complexity.Bookmark.Thread(childComplexity), true

	case "Bookmark.updatedAt":
		if e.complexity.Bookmark.UpdatedAt == nil {
			break
		}

		return e.complexity.Bookmark.UpdatedAt(childComplexity), true

	case "Bookmark.user":
		if e.complexity.Bookmark.User == nil {
			break
		}

		return e.complexity.Bookmark.User(childComplexity), true

	case "BookmarkConnection.edges":
		if e.complexity.BookmarkConnection.Edges == nil {
			break
		}

		return e.complexity.BookmarkConnection.Edges(childComplexity), true

	case "BookmarkConnection.pageInfo":
		if e.complexity.BookmarkConnection.PageInfo == nil {
			break
		}

		return e.complexity.BookmarkConnection.PageInfo(childComplexity), true

	case "BookmarkConnection.totalCount":
		if e.complexity.BookmarkConnection.TotalCount == nil {
			break
		}

		return e.complexity.BookmarkConnection.TotalCount(childComplexity), true

	case "BookmarkEdge.cursor":
		if e.complexity.BookmarkEdge.Cursor == nil {
			break
		}

		return e.complexity.BookmarkEdge.Cursor(childComplexity), true

	case "BookmarkEdge.node":
		if e.complexity.BookmarkEdge.Node == nil {
			break
		}

		return e.complexity.BookmarkEdge.Node(childComplexity), true

	case "Message.bookmarks":
		if e.complexity.Message.Bookmarks == nil {
			break
		}

		args, err := ec.field_Message_bookmarks_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Message.Bookmarks(childComplexity, args["after"].(*entgql.Cursor[pulid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[pulid.ID]), args["last"].(*int), args["orderBy"].([]*ent.BookmarkOrder), args["where"].(*ent.BookmarkWhereInput)), true

	case "Message.content":
		if e.complexity.Message.Content == nil {
			break
		}

		return e.complexity.Message.Content(childComplexity), true

	case "Message.createdAt":
		if e.complexity.Message.CreatedAt == nil {
			break
		}

		return e.complexity.Message.CreatedAt(childComplexity), true

	case "Message.id":
		if e.complexity.Message.ID == nil {
			break
		}

		return e.complexity.Message.ID(childComplexity), true

	case "Message.response":
		if e.complexity.Message.Response == nil {
			break
		}

		return e.complexity.Message.Response(childComplexity), true

	case "Message.sentBy":
		if e.complexity.Message.SentBy == nil {
			break
		}

		return e.complexity.Message.SentBy(childComplexity), true

	case "Message.thread":
		if e.complexity.Message.Thread == nil {
			break
		}

		return e.complexity.Message.Thread(childComplexity), true

	case "Message.updatedAt":
		if e.complexity.Message.UpdatedAt == nil {
			break
		}

		return e.complexity.Message.UpdatedAt(childComplexity), true

	case "MessageConnection.edges":
		if e.complexity.MessageConnection.Edges == nil {
			break
		}

		return e.complexity.MessageConnection.Edges(childComplexity), true

	case "MessageConnection.pageInfo":
		if e.complexity.MessageConnection.PageInfo == nil {
			break
		}

		return e.complexity.MessageConnection.PageInfo(childComplexity), true

	case "MessageConnection.totalCount":
		if e.complexity.MessageConnection.TotalCount == nil {
			break
		}

		return e.complexity.MessageConnection.TotalCount(childComplexity), true

	case "MessageEdge.cursor":
		if e.complexity.MessageEdge.Cursor == nil {
			break
		}

		return e.complexity.MessageEdge.Cursor(childComplexity), true

	case "MessageEdge.node":
		if e.complexity.MessageEdge.Node == nil {
			break
		}

		return e.complexity.MessageEdge.Node(childComplexity), true

	case "Mutation.createAgent":
		if e.complexity.Mutation.CreateAgent == nil {
			break
		}

		args, err := ec.field_Mutation_createAgent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateAgent(childComplexity, args["input"].(ent.CreateAgentInput)), true

	case "Mutation.createBookmark":
		if e.complexity.Mutation.CreateBookmark == nil {
			break
		}

		args, err := ec.field_Mutation_createBookmark_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateBookmark(childComplexity, args["input"].(ent.CreateBookmarkInput)), true

	case "Mutation.createMessage":
		if e.complexity.Mutation.CreateMessage == nil {
			break
		}

		args, err := ec.field_Mutation_createMessage_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateMessage(childComplexity, args["input"].(ent.CreateMessageInput)), true

	case "Mutation.createThread":
		if e.complexity.Mutation.CreateThread == nil {
			break
		}

		args, err := ec.field_Mutation_createThread_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateThread(childComplexity, args["input"].(ent.CreateThreadInput)), true

	case "Mutation.createUser":
		if e.complexity.Mutation.CreateUser == nil {
			break
		}

		args, err := ec.field_Mutation_createUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateUser(childComplexity, args["input"].(ent.CreateUserInput)), true

	case "Mutation.deleteBookmark":
		if e.complexity.Mutation.DeleteBookmark == nil {
			break
		}

		args, err := ec.field_Mutation_deleteBookmark_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteBookmark(childComplexity, args["id"].(pulid.ID)), true

	case "Mutation.deleteThread":
		if e.complexity.Mutation.DeleteThread == nil {
			break
		}

		args, err := ec.field_Mutation_deleteThread_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteThread(childComplexity, args["id"].(pulid.ID)), true

	case "Mutation.updateThread":
		if e.complexity.Mutation.UpdateThread == nil {
			break
		}

		args, err := ec.field_Mutation_updateThread_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateThread(childComplexity, args["id"].(pulid.ID), args["input"].(ent.UpdateThreadInput)), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "Query.agents":
		if e.complexity.Query.Agents == nil {
			break
		}

		args, err := ec.field_Query_agents_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Agents(childComplexity, args["after"].(*entgql.Cursor[pulid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[pulid.ID]), args["last"].(*int), args["orderBy"].([]*ent.AgentOrder), args["where"].(*ent.AgentWhereInput)), true

	case "Query.bookmarks":
		if e.complexity.Query.Bookmarks == nil {
			break
		}

		args, err := ec.field_Query_bookmarks_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Bookmarks(childComplexity, args["after"].(*entgql.Cursor[pulid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[pulid.ID]), args["last"].(*int), args["orderBy"].([]*ent.BookmarkOrder), args["where"].(*ent.BookmarkWhereInput)), true

	case "Query.messages":
		if e.complexity.Query.Messages == nil {
			break
		}

		args, err := ec.field_Query_messages_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Messages(childComplexity, args["after"].(*entgql.Cursor[pulid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[pulid.ID]), args["last"].(*int), args["orderBy"].([]*ent.MessageOrder), args["where"].(*ent.MessageWhereInput)), true

	case "Query.node":
		if e.complexity.Query.Node == nil {
			break
		}

		args, err := ec.field_Query_node_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Node(childComplexity, args["id"].(pulid.ID)), true

	case "Query.nodes":
		if e.complexity.Query.Nodes == nil {
			break
		}

		args, err := ec.field_Query_nodes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Nodes(childComplexity, args["ids"].([]pulid.ID)), true

	case "Query.responses":
		if e.complexity.Query.Responses == nil {
			break
		}

		args, err := ec.field_Query_responses_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Responses(childComplexity, args["after"].(*entgql.Cursor[pulid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[pulid.ID]), args["last"].(*int), args["orderBy"].([]*ent.ResponseOrder), args["where"].(*ent.ResponseWhereInput)), true

	case "Query.thread":
		if e.complexity.Query.Thread == nil {
			break
		}

		args, err := ec.field_Query_thread_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Thread(childComplexity, args["id"].(pulid.ID)), true

	case "Query.threads":
		if e.complexity.Query.Threads == nil {
			break
		}

		args, err := ec.field_Query_threads_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Threads(childComplexity, args["after"].(*entgql.Cursor[pulid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[pulid.ID]), args["last"].(*int), args["orderBy"].([]*ent.ThreadOrder), args["where"].(*ent.ThreadWhereInput)), true

	case "Query.user":
		if e.complexity.Query.User == nil {
			break
		}

		return e.complexity.Query.User(childComplexity), true

	case "Query.users":
		if e.complexity.Query.Users == nil {
			break
		}

		args, err := ec.field_Query_users_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Users(childComplexity, args["after"].(*entgql.Cursor[pulid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[pulid.ID]), args["last"].(*int), args["orderBy"].([]*ent.UserOrder), args["where"].(*ent.UserWhereInput)), true

	case "Response.bookmarks":
		if e.complexity.Response.Bookmarks == nil {
			break
		}

		args, err := ec.field_Response_bookmarks_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Response.Bookmarks(childComplexity, args["after"].(*entgql.Cursor[pulid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[pulid.ID]), args["last"].(*int), args["orderBy"].([]*ent.BookmarkOrder), args["where"].(*ent.BookmarkWhereInput)), true

	case "Response.content":
		if e.complexity.Response.Content == nil {
			break
		}

		return e.complexity.Response.Content(childComplexity), true

	case "Response.createdAt":
		if e.complexity.Response.CreatedAt == nil {
			break
		}

		return e.complexity.Response.CreatedAt(childComplexity), true

	case "Response.id":
		if e.complexity.Response.ID == nil {
			break
		}

		return e.complexity.Response.ID(childComplexity), true

	case "Response.message":
		if e.complexity.Response.Message == nil {
			break
		}

		return e.complexity.Response.Message(childComplexity), true

	case "Response.sentBy":
		if e.complexity.Response.SentBy == nil {
			break
		}

		return e.complexity.Response.SentBy(childComplexity), true

	case "Response.updatedAt":
		if e.complexity.Response.UpdatedAt == nil {
			break
		}

		return e.complexity.Response.UpdatedAt(childComplexity), true

	case "ResponseConnection.edges":
		if e.complexity.ResponseConnection.Edges == nil {
			break
		}

		return e.complexity.ResponseConnection.Edges(childComplexity), true

	case "ResponseConnection.pageInfo":
		if e.complexity.ResponseConnection.PageInfo == nil {
			break
		}

		return e.complexity.ResponseConnection.PageInfo(childComplexity), true

	case "ResponseConnection.totalCount":
		if e.complexity.ResponseConnection.TotalCount == nil {
			break
		}

		return e.complexity.ResponseConnection.TotalCount(childComplexity), true

	case "ResponseEdge.cursor":
		if e.complexity.ResponseEdge.Cursor == nil {
			break
		}

		return e.complexity.ResponseEdge.Cursor(childComplexity), true

	case "ResponseEdge.node":
		if e.complexity.ResponseEdge.Node == nil {
			break
		}

		return e.complexity.ResponseEdge.Node(childComplexity), true

	case "Thread.bookmarks":
		if e.complexity.Thread.Bookmarks == nil {
			break
		}

		args, err := ec.field_Thread_bookmarks_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Thread.Bookmarks(childComplexity, args["after"].(*entgql.Cursor[pulid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[pulid.ID]), args["last"].(*int), args["orderBy"].([]*ent.BookmarkOrder), args["where"].(*ent.BookmarkWhereInput)), true

	case "Thread.children":
		if e.complexity.Thread.Children == nil {
			break
		}

		args, err := ec.field_Thread_children_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Thread.Children(childComplexity, args["after"].(*entgql.Cursor[pulid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[pulid.ID]), args["last"].(*int), args["orderBy"].([]*ent.ThreadOrder), args["where"].(*ent.ThreadWhereInput)), true

	case "Thread.createdAt":
		if e.complexity.Thread.CreatedAt == nil {
			break
		}

		return e.complexity.Thread.CreatedAt(childComplexity), true

	case "Thread.createdBy":
		if e.complexity.Thread.CreatedBy == nil {
			break
		}

		return e.complexity.Thread.CreatedBy(childComplexity), true

	case "Thread.id":
		if e.complexity.Thread.ID == nil {
			break
		}

		return e.complexity.Thread.ID(childComplexity), true

	case "Thread.lastViewedAt":
		if e.complexity.Thread.LastViewedAt == nil {
			break
		}

		return e.complexity.Thread.LastViewedAt(childComplexity), true

	case "Thread.messages":
		if e.complexity.Thread.Messages == nil {
			break
		}

		args, err := ec.field_Thread_messages_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Thread.Messages(childComplexity, args["after"].(*entgql.Cursor[pulid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[pulid.ID]), args["last"].(*int), args["orderBy"].([]*ent.MessageOrder), args["where"].(*ent.MessageWhereInput)), true

	case "Thread.name":
		if e.complexity.Thread.Name == nil {
			break
		}

		return e.complexity.Thread.Name(childComplexity), true

	case "Thread.parent":
		if e.complexity.Thread.Parent == nil {
			break
		}

		return e.complexity.Thread.Parent(childComplexity), true

	case "Thread.updatedAt":
		if e.complexity.Thread.UpdatedAt == nil {
			break
		}

		return e.complexity.Thread.UpdatedAt(childComplexity), true

	case "ThreadConnection.edges":
		if e.complexity.ThreadConnection.Edges == nil {
			break
		}

		return e.complexity.ThreadConnection.Edges(childComplexity), true

	case "ThreadConnection.pageInfo":
		if e.complexity.ThreadConnection.PageInfo == nil {
			break
		}

		return e.complexity.ThreadConnection.PageInfo(childComplexity), true

	case "ThreadConnection.totalCount":
		if e.complexity.ThreadConnection.TotalCount == nil {
			break
		}

		return e.complexity.ThreadConnection.TotalCount(childComplexity), true

	case "ThreadEdge.cursor":
		if e.complexity.ThreadEdge.Cursor == nil {
			break
		}

		return e.complexity.ThreadEdge.Cursor(childComplexity), true

	case "ThreadEdge.node":
		if e.complexity.ThreadEdge.Node == nil {
			break
		}

		return e.complexity.ThreadEdge.Node(childComplexity), true

	case "User.bookmarks":
		if e.complexity.User.Bookmarks == nil {
			break
		}

		args, err := ec.field_User_bookmarks_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.Bookmarks(childComplexity, args["after"].(*entgql.Cursor[pulid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[pulid.ID]), args["last"].(*int), args["orderBy"].([]*ent.BookmarkOrder), args["where"].(*ent.BookmarkWhereInput)), true

	case "User.createdAt":
		if e.complexity.User.CreatedAt == nil {
			break
		}

		return e.complexity.User.CreatedAt(childComplexity), true

	case "User.email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.messages":
		if e.complexity.User.Messages == nil {
			break
		}

		args, err := ec.field_User_messages_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.Messages(childComplexity, args["after"].(*entgql.Cursor[pulid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[pulid.ID]), args["last"].(*int), args["orderBy"].([]*ent.MessageOrder), args["where"].(*ent.MessageWhereInput)), true

	case "User.threads":
		if e.complexity.User.Threads == nil {
			break
		}

		args, err := ec.field_User_threads_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.Threads(childComplexity, args["after"].(*entgql.Cursor[pulid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[pulid.ID]), args["last"].(*int), args["orderBy"].([]*ent.ThreadOrder), args["where"].(*ent.ThreadWhereInput)), true

	case "User.updatedAt":
		if e.complexity.User.UpdatedAt == nil {
			break
		}

		return e.complexity.User.UpdatedAt(childComplexity), true

	case "UserConnection.edges":
		if e.complexity.UserConnection.Edges == nil {
			break
		}

		return e.complexity.UserConnection.Edges(childComplexity), true

	case "UserConnection.pageInfo":
		if e.complexity.UserConnection.PageInfo == nil {
			break
		}

		return e.complexity.UserConnection.PageInfo(childComplexity), true

	case "UserConnection.totalCount":
		if e.complexity.UserConnection.TotalCount == nil {
			break
		}

		return e.complexity.UserConnection.TotalCount(childComplexity), true

	case "UserEdge.cursor":
		if e.complexity.UserEdge.Cursor == nil {
			break
		}

		return e.complexity.UserEdge.Cursor(childComplexity), true

	case "UserEdge.node":
		if e.complexity.UserEdge.Node == nil {
			break
		}

		return e.complexity.UserEdge.Node(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputAgentOrder,
		ec.unmarshalInputAgentWhereInput,
		ec.unmarshalInputBookmarkOrder,
		ec.unmarshalInputBookmarkWhereInput,
		ec.unmarshalInputCreateAgentInput,
		ec.unmarshalInputCreateBookmarkInput,
		ec.unmarshalInputCreateMessageInput,
		ec.unmarshalInputCreateResponseInput,
		ec.unmarshalInputCreateThreadInput,
		ec.unmarshalInputCreateUserInput,
		ec.unmarshalInputMessageOrder,
		ec.unmarshalInputMessageWhereInput,
		ec.unmarshalInputResponseOrder,
		ec.unmarshalInputResponseWhereInput,
		ec.unmarshalInputThreadOrder,
		ec.unmarshalInputThreadWhereInput,
		ec.unmarshalInputUpdateAgentInput,
		ec.unmarshalInputUpdateBookmarkInput,
		ec.unmarshalInputUpdateMessageInput,
		ec.unmarshalInputUpdateResponseInput,
		ec.unmarshalInputUpdateThreadInput,
		ec.unmarshalInputUpdateUserInput,
		ec.unmarshalInputUserOrder,
		ec.unmarshalInputUserWhereInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, rc.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../graphql_schema/agent.graphql", Input: `extend type Mutation {
    createAgent(input: CreateAgentInput!): Agent
}`, BuiltIn: false},
	{Name: "../graphql_schema/bookmark.graphql", Input: `extend type Mutation {
    createBookmark(input: CreateBookmarkInput!): BookmarkConnection
    deleteBookmark(id: ID!):ID!
}`, BuiltIn: false},
	{Name: "../graphql_schema/ent.graphql", Input: `directive @goField(forceResolver: Boolean, name: String, omittable: Boolean) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION
directive @goModel(model: String, models: [String!], forceGenerate: Boolean) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION
type Agent implements Node {
  id: ID!
  createdAt: Time!
  updatedAt: Time!
  provider: String!
  model: String!
  responses(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Responses returned from the connection.
    """
    orderBy: [ResponseOrder!]

    """
    Filtering options for Responses returned from the connection.
    """
    where: ResponseWhereInput
  ): ResponseConnection!
}
"""
A connection to a list of items.
"""
type AgentConnection {
  """
  A list of edges.
  """
  edges: [AgentEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type AgentEdge {
  """
  The item at the end of the edge.
  """
  node: Agent
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
Ordering options for Agent connections
"""
input AgentOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order Agents.
  """
  field: AgentOrderField!
}
"""
Properties by which Agent connections can be ordered.
"""
enum AgentOrderField {
  CREATED_AT
  UPDATED_AT
  PROVIDER
  MODEL
}
"""
AgentWhereInput is used for filtering Agent objects.
Input was generated by ent.
"""
input AgentWhereInput {
  not: AgentWhereInput
  and: [AgentWhereInput!]
  or: [AgentWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  created_at field predicates
  """
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """
  updated_at field predicates
  """
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """
  provider field predicates
  """
  provider: String
  providerNEQ: String
  providerIn: [String!]
  providerNotIn: [String!]
  providerGT: String
  providerGTE: String
  providerLT: String
  providerLTE: String
  providerContains: String
  providerHasPrefix: String
  providerHasSuffix: String
  providerEqualFold: String
  providerContainsFold: String
  """
  model field predicates
  """
  model: String
  modelNEQ: String
  modelIn: [String!]
  modelNotIn: [String!]
  modelGT: String
  modelGTE: String
  modelLT: String
  modelLTE: String
  modelContains: String
  modelHasPrefix: String
  modelHasSuffix: String
  modelEqualFold: String
  modelContainsFold: String
  """
  responses edge predicates
  """
  hasResponses: Boolean
  hasResponsesWith: [ResponseWhereInput!]
}
type Bookmark implements Node {
  id: ID!
  createdAt: Time!
  updatedAt: Time!
  user: User!
  thread: Thread
  message: Message
  response: Response
}
"""
A connection to a list of items.
"""
type BookmarkConnection {
  """
  A list of edges.
  """
  edges: [BookmarkEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type BookmarkEdge {
  """
  The item at the end of the edge.
  """
  node: Bookmark
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
Ordering options for Bookmark connections
"""
input BookmarkOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order Bookmarks.
  """
  field: BookmarkOrderField!
}
"""
Properties by which Bookmark connections can be ordered.
"""
enum BookmarkOrderField {
  CREATED_AT
  UPDATED_AT
}
"""
BookmarkWhereInput is used for filtering Bookmark objects.
Input was generated by ent.
"""
input BookmarkWhereInput {
  not: BookmarkWhereInput
  and: [BookmarkWhereInput!]
  or: [BookmarkWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  created_at field predicates
  """
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """
  updated_at field predicates
  """
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """
  user edge predicates
  """
  hasUser: Boolean
  hasUserWith: [UserWhereInput!]
  """
  thread edge predicates
  """
  hasThread: Boolean
  hasThreadWith: [ThreadWhereInput!]
  """
  message edge predicates
  """
  hasMessage: Boolean
  hasMessageWith: [MessageWhereInput!]
  """
  response edge predicates
  """
  hasResponse: Boolean
  hasResponseWith: [ResponseWhereInput!]
}
"""
CreateAgentInput is used for create Agent object.
Input was generated by ent.
"""
input CreateAgentInput {
  provider: String!
  model: String!
  responseIDs: [ID!]
}
"""
CreateBookmarkInput is used for create Bookmark object.
Input was generated by ent.
"""
input CreateBookmarkInput {
  userID: ID!
  threadID: ID
  messageID: ID
  responseID: ID
}
"""
CreateMessageInput is used for create Message object.
Input was generated by ent.
"""
input CreateMessageInput {
  content: String!
  sentByID: ID!
  threadID: ID!
  bookmarkIDs: [ID!]
  responseID: ID
}
"""
CreateResponseInput is used for create Response object.
Input was generated by ent.
"""
input CreateResponseInput {
  content: String
  sentByID: ID!
  messageID: ID!
  bookmarkIDs: [ID!]
}
"""
CreateThreadInput is used for create Thread object.
Input was generated by ent.
"""
input CreateThreadInput {
  name: String!
  lastViewedAt: Time
  messageIDs: [ID!]
  bookmarkIDs: [ID!]
  parentID: ID
  childIDs: [ID!]
}
"""
CreateUserInput is used for create User object.
Input was generated by ent.
"""
input CreateUserInput {
  email: String!
  bookmarkIDs: [ID!]
  threadIDs: [ID!]
  messageIDs: [ID!]
}
"""
Define a Relay Cursor type:
https://relay.dev/graphql/connections.htm#sec-Cursor
"""
scalar Cursor
type Message implements Node {
  id: ID!
  createdAt: Time!
  updatedAt: Time!
  content: String!
  sentBy: User!
  thread: Thread!
  bookmarks(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Bookmarks returned from the connection.
    """
    orderBy: [BookmarkOrder!]

    """
    Filtering options for Bookmarks returned from the connection.
    """
    where: BookmarkWhereInput
  ): BookmarkConnection!
  response: Response
}
"""
A connection to a list of items.
"""
type MessageConnection {
  """
  A list of edges.
  """
  edges: [MessageEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type MessageEdge {
  """
  The item at the end of the edge.
  """
  node: Message
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
Ordering options for Message connections
"""
input MessageOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order Messages.
  """
  field: MessageOrderField!
}
"""
Properties by which Message connections can be ordered.
"""
enum MessageOrderField {
  CREATED_AT
  UPDATED_AT
}
"""
MessageWhereInput is used for filtering Message objects.
Input was generated by ent.
"""
input MessageWhereInput {
  not: MessageWhereInput
  and: [MessageWhereInput!]
  or: [MessageWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  created_at field predicates
  """
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """
  updated_at field predicates
  """
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """
  content field predicates
  """
  content: String
  contentNEQ: String
  contentIn: [String!]
  contentNotIn: [String!]
  contentGT: String
  contentGTE: String
  contentLT: String
  contentLTE: String
  contentContains: String
  contentHasPrefix: String
  contentHasSuffix: String
  contentEqualFold: String
  contentContainsFold: String
  """
  sent_by edge predicates
  """
  hasSentBy: Boolean
  hasSentByWith: [UserWhereInput!]
  """
  thread edge predicates
  """
  hasThread: Boolean
  hasThreadWith: [ThreadWhereInput!]
  """
  bookmarks edge predicates
  """
  hasBookmarks: Boolean
  hasBookmarksWith: [BookmarkWhereInput!]
  """
  response edge predicates
  """
  hasResponse: Boolean
  hasResponseWith: [ResponseWhereInput!]
}
"""
An object with an ID.
Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
"""
interface Node @goModel(model: "github.com/codelite7/momentum/api/ent.Noder") {
  """
  The id of the object.
  """
  id: ID!
}
"""
Possible directions in which to order a list of items when provided an ` + "`" + `orderBy` + "`" + ` argument.
"""
enum OrderDirection {
  """
  Specifies an ascending order for a given ` + "`" + `orderBy` + "`" + ` argument.
  """
  ASC
  """
  Specifies a descending order for a given ` + "`" + `orderBy` + "`" + ` argument.
  """
  DESC
}
"""
Information about pagination in a connection.
https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
"""
type PageInfo {
  """
  When paginating forwards, are there more items?
  """
  hasNextPage: Boolean!
  """
  When paginating backwards, are there more items?
  """
  hasPreviousPage: Boolean!
  """
  When paginating backwards, the cursor to continue.
  """
  startCursor: Cursor
  """
  When paginating forwards, the cursor to continue.
  """
  endCursor: Cursor
}
type Query {
  """
  Fetches an object given its ID.
  """
  node(
    """
    ID of the object.
    """
    id: ID!
  ): Node
  """
  Lookup nodes by a list of IDs.
  """
  nodes(
    """
    The list of node IDs.
    """
    ids: [ID!]!
  ): [Node]!
  agents(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Agents returned from the connection.
    """
    orderBy: [AgentOrder!]

    """
    Filtering options for Agents returned from the connection.
    """
    where: AgentWhereInput
  ): AgentConnection!
  bookmarks(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Bookmarks returned from the connection.
    """
    orderBy: [BookmarkOrder!]

    """
    Filtering options for Bookmarks returned from the connection.
    """
    where: BookmarkWhereInput
  ): BookmarkConnection!
  messages(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Messages returned from the connection.
    """
    orderBy: [MessageOrder!]

    """
    Filtering options for Messages returned from the connection.
    """
    where: MessageWhereInput
  ): MessageConnection!
  responses(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Responses returned from the connection.
    """
    orderBy: [ResponseOrder!]

    """
    Filtering options for Responses returned from the connection.
    """
    where: ResponseWhereInput
  ): ResponseConnection!
  threads(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Threads returned from the connection.
    """
    orderBy: [ThreadOrder!]

    """
    Filtering options for Threads returned from the connection.
    """
    where: ThreadWhereInput
  ): ThreadConnection!
  users(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Users returned from the connection.
    """
    orderBy: [UserOrder!]

    """
    Filtering options for Users returned from the connection.
    """
    where: UserWhereInput
  ): UserConnection!
}
type Response implements Node {
  id: ID!
  createdAt: Time!
  updatedAt: Time!
  content: String
  sentBy: Agent!
  message: Message!
  bookmarks(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Bookmarks returned from the connection.
    """
    orderBy: [BookmarkOrder!]

    """
    Filtering options for Bookmarks returned from the connection.
    """
    where: BookmarkWhereInput
  ): BookmarkConnection!
}
"""
A connection to a list of items.
"""
type ResponseConnection {
  """
  A list of edges.
  """
  edges: [ResponseEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type ResponseEdge {
  """
  The item at the end of the edge.
  """
  node: Response
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
Ordering options for Response connections
"""
input ResponseOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order Responses.
  """
  field: ResponseOrderField!
}
"""
Properties by which Response connections can be ordered.
"""
enum ResponseOrderField {
  CREATED_AT
  UPDATED_AT
}
"""
ResponseWhereInput is used for filtering Response objects.
Input was generated by ent.
"""
input ResponseWhereInput {
  not: ResponseWhereInput
  and: [ResponseWhereInput!]
  or: [ResponseWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  created_at field predicates
  """
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """
  updated_at field predicates
  """
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """
  content field predicates
  """
  content: String
  contentNEQ: String
  contentIn: [String!]
  contentNotIn: [String!]
  contentGT: String
  contentGTE: String
  contentLT: String
  contentLTE: String
  contentContains: String
  contentHasPrefix: String
  contentHasSuffix: String
  contentIsNil: Boolean
  contentNotNil: Boolean
  contentEqualFold: String
  contentContainsFold: String
  """
  sent_by edge predicates
  """
  hasSentBy: Boolean
  hasSentByWith: [AgentWhereInput!]
  """
  message edge predicates
  """
  hasMessage: Boolean
  hasMessageWith: [MessageWhereInput!]
  """
  bookmarks edge predicates
  """
  hasBookmarks: Boolean
  hasBookmarksWith: [BookmarkWhereInput!]
}
type Thread implements Node {
  id: ID!
  createdAt: Time!
  updatedAt: Time!
  name: String!
  lastViewedAt: Time!
  createdBy: User!
  messages(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Messages returned from the connection.
    """
    orderBy: [MessageOrder!]

    """
    Filtering options for Messages returned from the connection.
    """
    where: MessageWhereInput
  ): MessageConnection!
  bookmarks(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Bookmarks returned from the connection.
    """
    orderBy: [BookmarkOrder!]

    """
    Filtering options for Bookmarks returned from the connection.
    """
    where: BookmarkWhereInput
  ): BookmarkConnection!
  parent: Thread
  children(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Threads returned from the connection.
    """
    orderBy: [ThreadOrder!]

    """
    Filtering options for Threads returned from the connection.
    """
    where: ThreadWhereInput
  ): ThreadConnection!
}
"""
A connection to a list of items.
"""
type ThreadConnection {
  """
  A list of edges.
  """
  edges: [ThreadEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type ThreadEdge {
  """
  The item at the end of the edge.
  """
  node: Thread
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
Ordering options for Thread connections
"""
input ThreadOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order Threads.
  """
  field: ThreadOrderField!
}
"""
Properties by which Thread connections can be ordered.
"""
enum ThreadOrderField {
  CREATED_AT
  UPDATED_AT
  NAME
  LAST_VIEWED_AT
}
"""
ThreadWhereInput is used for filtering Thread objects.
Input was generated by ent.
"""
input ThreadWhereInput {
  not: ThreadWhereInput
  and: [ThreadWhereInput!]
  or: [ThreadWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  created_at field predicates
  """
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """
  updated_at field predicates
  """
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """
  name field predicates
  """
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """
  last_viewed_at field predicates
  """
  lastViewedAt: Time
  lastViewedAtNEQ: Time
  lastViewedAtIn: [Time!]
  lastViewedAtNotIn: [Time!]
  lastViewedAtGT: Time
  lastViewedAtGTE: Time
  lastViewedAtLT: Time
  lastViewedAtLTE: Time
  """
  created_by edge predicates
  """
  hasCreatedBy: Boolean
  hasCreatedByWith: [UserWhereInput!]
  """
  messages edge predicates
  """
  hasMessages: Boolean
  hasMessagesWith: [MessageWhereInput!]
  """
  bookmarks edge predicates
  """
  hasBookmarks: Boolean
  hasBookmarksWith: [BookmarkWhereInput!]
  """
  parent edge predicates
  """
  hasParent: Boolean
  hasParentWith: [ThreadWhereInput!]
  """
  children edge predicates
  """
  hasChildren: Boolean
  hasChildrenWith: [ThreadWhereInput!]
}
"""
The builtin Time type
"""
scalar Time
"""
UpdateAgentInput is used for update Agent object.
Input was generated by ent.
"""
input UpdateAgentInput {
  provider: String
  model: String
  addResponseIDs: [ID!]
  removeResponseIDs: [ID!]
  clearResponses: Boolean
}
"""
UpdateBookmarkInput is used for update Bookmark object.
Input was generated by ent.
"""
input UpdateBookmarkInput {
  userID: ID
  threadID: ID
  clearThread: Boolean
  messageID: ID
  clearMessage: Boolean
  responseID: ID
  clearResponse: Boolean
}
"""
UpdateMessageInput is used for update Message object.
Input was generated by ent.
"""
input UpdateMessageInput {
  content: String
  sentByID: ID
  threadID: ID
  addBookmarkIDs: [ID!]
  removeBookmarkIDs: [ID!]
  clearBookmarks: Boolean
  responseID: ID
  clearResponse: Boolean
}
"""
UpdateResponseInput is used for update Response object.
Input was generated by ent.
"""
input UpdateResponseInput {
  content: String
  clearContent: Boolean
  sentByID: ID
  messageID: ID
  addBookmarkIDs: [ID!]
  removeBookmarkIDs: [ID!]
  clearBookmarks: Boolean
}
"""
UpdateThreadInput is used for update Thread object.
Input was generated by ent.
"""
input UpdateThreadInput {
  name: String
  lastViewedAt: Time
  addMessageIDs: [ID!]
  removeMessageIDs: [ID!]
  clearMessages: Boolean
  addBookmarkIDs: [ID!]
  removeBookmarkIDs: [ID!]
  clearBookmarks: Boolean
  parentID: ID
  clearParent: Boolean
  addChildIDs: [ID!]
  removeChildIDs: [ID!]
  clearChildren: Boolean
}
"""
UpdateUserInput is used for update User object.
Input was generated by ent.
"""
input UpdateUserInput {
  email: String
  addBookmarkIDs: [ID!]
  removeBookmarkIDs: [ID!]
  clearBookmarks: Boolean
  addThreadIDs: [ID!]
  removeThreadIDs: [ID!]
  clearThreads: Boolean
  addMessageIDs: [ID!]
  removeMessageIDs: [ID!]
  clearMessages: Boolean
}
type User implements Node {
  id: ID!
  createdAt: Time!
  updatedAt: Time!
  email: String!
  bookmarks(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Bookmarks returned from the connection.
    """
    orderBy: [BookmarkOrder!]

    """
    Filtering options for Bookmarks returned from the connection.
    """
    where: BookmarkWhereInput
  ): BookmarkConnection!
  threads(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Threads returned from the connection.
    """
    orderBy: [ThreadOrder!]

    """
    Filtering options for Threads returned from the connection.
    """
    where: ThreadWhereInput
  ): ThreadConnection!
  messages(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Messages returned from the connection.
    """
    orderBy: [MessageOrder!]

    """
    Filtering options for Messages returned from the connection.
    """
    where: MessageWhereInput
  ): MessageConnection!
}
"""
A connection to a list of items.
"""
type UserConnection {
  """
  A list of edges.
  """
  edges: [UserEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type UserEdge {
  """
  The item at the end of the edge.
  """
  node: User
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
Ordering options for User connections
"""
input UserOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order Users.
  """
  field: UserOrderField!
}
"""
Properties by which User connections can be ordered.
"""
enum UserOrderField {
  CREATED_AT
  UPDATED_AT
  EMAIL
}
"""
UserWhereInput is used for filtering User objects.
Input was generated by ent.
"""
input UserWhereInput {
  not: UserWhereInput
  and: [UserWhereInput!]
  or: [UserWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  created_at field predicates
  """
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """
  updated_at field predicates
  """
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """
  email field predicates
  """
  email: String
  emailNEQ: String
  emailIn: [String!]
  emailNotIn: [String!]
  emailGT: String
  emailGTE: String
  emailLT: String
  emailLTE: String
  emailContains: String
  emailHasPrefix: String
  emailHasSuffix: String
  emailEqualFold: String
  emailContainsFold: String
  """
  bookmarks edge predicates
  """
  hasBookmarks: Boolean
  hasBookmarksWith: [BookmarkWhereInput!]
  """
  threads edge predicates
  """
  hasThreads: Boolean
  hasThreadsWith: [ThreadWhereInput!]
  """
  messages edge predicates
  """
  hasMessages: Boolean
  hasMessagesWith: [MessageWhereInput!]
}
`, BuiltIn: false},
	{Name: "../graphql_schema/message.graphql", Input: `extend type Mutation {
    createMessage(input: CreateMessageInput!): Message
}`, BuiltIn: false},
	{Name: "../graphql_schema/thread.graphql", Input: `extend type Mutation {
    createThread(input: CreateThreadInput!): Thread!
    updateThread(id: ID!, input: UpdateThreadInput!): Thread!
    deleteThread(id: ID!):ID!
}

extend type Query {
    thread(id:ID!): Thread!
}`, BuiltIn: false},
	{Name: "../graphql_schema/user.graphql", Input: `extend type Mutation {
    createUser(input: CreateUserInput!): User
}

extend type Query {
    user:User! # no args, api uses jwt to pull the user so this is specific to the authenticated user
}`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
